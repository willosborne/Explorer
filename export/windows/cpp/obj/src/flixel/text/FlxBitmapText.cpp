// Generated by Haxe 3.4.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxBitmapFont
#include <flixel/graphics/frames/FlxBitmapFont.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFrame
#include <flixel/graphics/frames/FlxFrame.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFramesCollection
#include <flixel/graphics/frames/FlxFramesCollection.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxDrawBaseItem
#include <flixel/graphics/tile/FlxDrawBaseItem.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxDrawTilesItem
#include <flixel/graphics/tile/FlxDrawTilesItem.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMatrix
#include <flixel/math/FlxMatrix.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_BitmapFrontEnd
#include <flixel/system/frontEnds/BitmapFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_DebuggerFrontEnd
#include <flixel/system/frontEnds/DebuggerFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_text_FlxBitmapText
#include <flixel/text/FlxBitmapText.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextBorderStyle
#include <flixel/text/FlxTextBorderStyle.h>
#endif
#ifndef INCLUDED_flixel_util_FlxColorTransformUtil
#include <flixel/util/FlxColorTransformUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxDestroyUtil
#include <flixel/util/FlxDestroyUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxPoint
#include <flixel/util/FlxPool_flixel_math_FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Utf8
#include <haxe/Utf8.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_BitmapData
#include <openfl/_legacy/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_BlendMode
#include <openfl/_legacy/display/BlendMode.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_IBitmapDrawable
#include <openfl/_legacy/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_ColorTransform
#include <openfl/_legacy/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Matrix
#include <openfl/_legacy/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Point
#include <openfl/_legacy/geom/Point.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Rectangle
#include <openfl/_legacy/geom/Rectangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_25_new,"flixel.text.FlxBitmapText","new",0x8de9daf1,"flixel.text.FlxBitmapText.new","flixel/text/FlxBitmapText.hx",25,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_228_destroy,"flixel.text.FlxBitmapText","destroy",0xb403540b,"flixel.text.FlxBitmapText.destroy","flixel/text/FlxBitmapText.hx",228,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_252_drawFrame,"flixel.text.FlxBitmapText","drawFrame",0x14f07ada,"flixel.text.FlxBitmapText.drawFrame","flixel/text/FlxBitmapText.hx",252,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_266_checkPendingChanges,"flixel.text.FlxBitmapText","checkPendingChanges",0xc17800e5,"flixel.text.FlxBitmapText.checkPendingChanges","flixel/text/FlxBitmapText.hx",266,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_292_draw,"flixel.text.FlxBitmapText","draw",0x98236053,"flixel.text.FlxBitmapText.draw","flixel/text/FlxBitmapText.hx",292,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_459_set_color,"flixel.text.FlxBitmapText","set_color",0xb7b88717,"flixel.text.FlxBitmapText.set_color","flixel/text/FlxBitmapText.hx",459,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_469_set_alpha,"flixel.text.FlxBitmapText","set_alpha",0x8ef2bd12,"flixel.text.FlxBitmapText.set_alpha","flixel/text/FlxBitmapText.hx",469,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_479_set_textColor,"flixel.text.FlxBitmapText","set_textColor",0x3cf5012a,"flixel.text.FlxBitmapText.set_textColor","flixel/text/FlxBitmapText.hx",479,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_493_set_useTextColor,"flixel.text.FlxBitmapText","set_useTextColor",0xe3de3cfb,"flixel.text.FlxBitmapText.set_useTextColor","flixel/text/FlxBitmapText.hx",493,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_508_calcFrame,"flixel.text.FlxBitmapText","calcFrame",0x3fee60a9,"flixel.text.FlxBitmapText.calcFrame","flixel/text/FlxBitmapText.hx",508,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_519_set_text,"flixel.text.FlxBitmapText","set_text",0x7916e979,"flixel.text.FlxBitmapText.set_text","flixel/text/FlxBitmapText.hx",519,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_530_updateText,"flixel.text.FlxBitmapText","updateText",0x54e090e5,"flixel.text.FlxBitmapText.updateText","flixel/text/FlxBitmapText.hx",530,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_566_computeTextSize,"flixel.text.FlxBitmapText","computeTextSize",0x8453e6b6,"flixel.text.FlxBitmapText.computeTextSize","flixel/text/FlxBitmapText.hx",566,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_590_getLineWidth,"flixel.text.FlxBitmapText","getLineWidth",0x033af14b,"flixel.text.FlxBitmapText.getLineWidth","flixel/text/FlxBitmapText.hx",590,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_606_getStringWidth,"flixel.text.FlxBitmapText","getStringWidth",0xe2e3078e,"flixel.text.FlxBitmapText.getStringWidth","flixel/text/FlxBitmapText.hx",606,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_656_cutLines,"flixel.text.FlxBitmapText","cutLines",0x876b98ec,"flixel.text.FlxBitmapText.cutLines","flixel/text/FlxBitmapText.hx",656,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_724_wrap,"flixel.text.FlxBitmapText","wrap",0xa4b26e19,"flixel.text.FlxBitmapText.wrap","flixel/text/FlxBitmapText.hx",724,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_755_splitLineIntoWords,"flixel.text.FlxBitmapText","splitLineIntoWords",0x05b5c56a,"flixel.text.FlxBitmapText.splitLineIntoWords","flixel/text/FlxBitmapText.hx",755,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_830_wrapLineByWord,"flixel.text.FlxBitmapText","wrapLineByWord",0x3ea521ce,"flixel.text.FlxBitmapText.wrapLineByWord","flixel/text/FlxBitmapText.hx",830,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_937_wrapLineByCharacter,"flixel.text.FlxBitmapText","wrapLineByCharacter",0x96232d25,"flixel.text.FlxBitmapText.wrapLineByCharacter","flixel/text/FlxBitmapText.hx",937,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1048_updateTextBitmap,"flixel.text.FlxBitmapText","updateTextBitmap",0xa8004eb4,"flixel.text.FlxBitmapText.updateTextBitmap","flixel/text/FlxBitmapText.hx",1048,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1118_drawLine,"flixel.text.FlxBitmapText","drawLine",0x5a21c9e7,"flixel.text.FlxBitmapText.drawLine","flixel/text/FlxBitmapText.hx",1118,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1135_blitLine,"flixel.text.FlxBitmapText","blitLine",0x66e34298,"flixel.text.FlxBitmapText.blitLine","flixel/text/FlxBitmapText.hx",1135,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1201_tileLine,"flixel.text.FlxBitmapText","tileLine",0x7fbe4611,"flixel.text.FlxBitmapText.tileLine","flixel/text/FlxBitmapText.hx",1201,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1270_updatePixels,"flixel.text.FlxBitmapText","updatePixels",0x6ef43165,"flixel.text.FlxBitmapText.updatePixels","flixel/text/FlxBitmapText.hx",1270,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1417_drawText,"flixel.text.FlxBitmapText","drawText",0x5f687ea0,"flixel.text.FlxBitmapText.drawText","flixel/text/FlxBitmapText.hx",1417,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1434_blitText,"flixel.text.FlxBitmapText","blitText",0x6c29f751,"flixel.text.FlxBitmapText.blitText","flixel/text/FlxBitmapText.hx",1434,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1465_tileText,"flixel.text.FlxBitmapText","tileText",0x8504faca,"flixel.text.FlxBitmapText.tileText","flixel/text/FlxBitmapText.hx",1465,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1492_setBorderStyle,"flixel.text.FlxBitmapText","setBorderStyle",0x3e33f932,"flixel.text.FlxBitmapText.setBorderStyle","flixel/text/FlxBitmapText.hx",1492,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1506_get_fieldWidth,"flixel.text.FlxBitmapText","get_fieldWidth",0x93ba0444,"flixel.text.FlxBitmapText.get_fieldWidth","flixel/text/FlxBitmapText.hx",1506,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1513_set_fieldWidth,"flixel.text.FlxBitmapText","set_fieldWidth",0xb3d9ecb8,"flixel.text.FlxBitmapText.set_fieldWidth","flixel/text/FlxBitmapText.hx",1513,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1531_set_alignment,"flixel.text.FlxBitmapText","set_alignment",0x43e8e297,"flixel.text.FlxBitmapText.set_alignment","flixel/text/FlxBitmapText.hx",1531,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1542_set_multiLine,"flixel.text.FlxBitmapText","set_multiLine",0xe295fec1,"flixel.text.FlxBitmapText.set_multiLine","flixel/text/FlxBitmapText.hx",1542,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1553_set_font,"flixel.text.FlxBitmapText","set_font",0x6fdd7a9b,"flixel.text.FlxBitmapText.set_font","flixel/text/FlxBitmapText.hx",1553,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1564_set_lineSpacing,"flixel.text.FlxBitmapText","set_lineSpacing",0x2a403ea3,"flixel.text.FlxBitmapText.set_lineSpacing","flixel/text/FlxBitmapText.hx",1564,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1575_set_letterSpacing,"flixel.text.FlxBitmapText","set_letterSpacing",0x3dbaa0f1,"flixel.text.FlxBitmapText.set_letterSpacing","flixel/text/FlxBitmapText.hx",1575,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1586_set_autoUpperCase,"flixel.text.FlxBitmapText","set_autoUpperCase",0xfc20c177,"flixel.text.FlxBitmapText.set_autoUpperCase","flixel/text/FlxBitmapText.hx",1586,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1597_set_wordWrap,"flixel.text.FlxBitmapText","set_wordWrap",0xad748780,"flixel.text.FlxBitmapText.set_wordWrap","flixel/text/FlxBitmapText.hx",1597,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1608_set_wrapByWord,"flixel.text.FlxBitmapText","set_wrapByWord",0x94749a77,"flixel.text.FlxBitmapText.set_wrapByWord","flixel/text/FlxBitmapText.hx",1608,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1619_set_autoSize,"flixel.text.FlxBitmapText","set_autoSize",0xdc13029c,"flixel.text.FlxBitmapText.set_autoSize","flixel/text/FlxBitmapText.hx",1619,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1630_set_padding,"flixel.text.FlxBitmapText","set_padding",0x5d514485,"flixel.text.FlxBitmapText.set_padding","flixel/text/FlxBitmapText.hx",1630,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1641_set_numSpacesInTab,"flixel.text.FlxBitmapText","set_numSpacesInTab",0x862ece69,"flixel.text.FlxBitmapText.set_numSpacesInTab","flixel/text/FlxBitmapText.hx",1641,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1652_set_background,"flixel.text.FlxBitmapText","set_background",0x421251ba,"flixel.text.FlxBitmapText.set_background","flixel/text/FlxBitmapText.hx",1652,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1666_set_backgroundColor,"flixel.text.FlxBitmapText","set_backgroundColor",0x20d30d49,"flixel.text.FlxBitmapText.set_backgroundColor","flixel/text/FlxBitmapText.hx",1666,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1680_set_borderStyle,"flixel.text.FlxBitmapText","set_borderStyle",0x6ac7c559,"flixel.text.FlxBitmapText.set_borderStyle","flixel/text/FlxBitmapText.hx",1680,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1691_set_borderColor,"flixel.text.FlxBitmapText","set_borderColor",0x3106918b,"flixel.text.FlxBitmapText.set_borderColor","flixel/text/FlxBitmapText.hx",1691,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1705_set_borderSize,"flixel.text.FlxBitmapText","set_borderSize",0x22e2bd99,"flixel.text.FlxBitmapText.set_borderSize","flixel/text/FlxBitmapText.hx",1705,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1720_set_borderQuality,"flixel.text.FlxBitmapText","set_borderQuality",0xc1dc7ee7,"flixel.text.FlxBitmapText.set_borderQuality","flixel/text/FlxBitmapText.hx",1720,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1738_get_numLines,"flixel.text.FlxBitmapText","get_numLines",0xc9b24131,"flixel.text.FlxBitmapText.get_numLines","flixel/text/FlxBitmapText.hx",1738,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1747_get_textWidth,"flixel.text.FlxBitmapText","get_textWidth",0x77f563c1,"flixel.text.FlxBitmapText.get_textWidth","flixel/text/FlxBitmapText.hx",1747,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1765_get_textHeight,"flixel.text.FlxBitmapText","get_textHeight",0x35115dcc,"flixel.text.FlxBitmapText.get_textHeight","flixel/text/FlxBitmapText.hx",1765,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1770_get_lineHeight,"flixel.text.FlxBitmapText","get_lineHeight",0xd2c8d853,"flixel.text.FlxBitmapText.get_lineHeight","flixel/text/FlxBitmapText.hx",1770,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1774_get_width,"flixel.text.FlxBitmapText","get_width",0x546ddfae,"flixel.text.FlxBitmapText.get_width","flixel/text/FlxBitmapText.hx",1774,0x5518a9ff)
HX_LOCAL_STACK_FRAME(_hx_pos_9e790623cbe1e5f4_1780_get_height,"flixel.text.FlxBitmapText","get_height",0x4205513f,"flixel.text.FlxBitmapText.get_height","flixel/text/FlxBitmapText.hx",1780,0x5518a9ff)
namespace flixel{
namespace text{

void FlxBitmapText_obj::__construct( ::flixel::graphics::frames::FlxBitmapFont font){
            	HX_GC_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_25_new)
HXLINE( 185)		this->pendingPixelsChange = true;
HXLINE( 184)		this->pendingTextBitmapChange = true;
HXLINE( 183)		this->pendingTextChange = true;
HXLINE( 173)		this->numLines = (int)0;
HXLINE( 168)		this->multiLine = true;
HXLINE( 163)		this->backgroundColor = (int)0;
HXLINE( 158)		this->background = false;
HXLINE( 147)		this->borderQuality = ((Float)0);
HXLINE( 140)		this->borderSize = ((Float)1);
HXLINE( 135)		this->borderColor = (int)-16777216;
HXLINE( 130)		this->borderStyle = ::flixel::text::FlxTextBorderStyle_obj::NONE_dyn();
HXLINE( 125)		this->useTextColor = false;
HXLINE( 120)		this->textColor = (int)-1;
HXLINE( 114)		this->numSpacesInTab = (int)4;
HXLINE(  94)		this->padding = (int)0;
HXLINE(  89)		this->autoSize = true;
HXLINE(  83)		this->wrapByWord = true;
HXLINE(  77)		this->wordWrap = true;
HXLINE(  72)		this->autoUpperCase = false;
HXLINE(  67)		this->letterSpacing = (int)0;
HXLINE(  62)		this->lineSpacing = (int)0;
HXLINE(  57)		this->alignment = HX_("left",07,08,b0,47);
HXLINE(  50)		this->_linesWidth = ::Array_obj< int >::__new(0);
HXLINE(  46)		this->_lines = ::Array_obj< ::String >::__new(0);
HXLINE(  40)		this->_colorParams =  ::openfl::_legacy::geom::ColorTransform_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null(),null(),null());
HXLINE(  35)		this->text = HX_("",00,00,00,00);
HXLINE( 202)		super::__construct(null(),null(),null());
HXLINE( 204)		this->set_width(this->set_fieldWidth((int)2));
HXLINE( 205)		this->set_alpha((int)1);
HXLINE( 207)		 ::flixel::graphics::frames::FlxBitmapFont _hx_tmp;
HXDLIN( 207)		if (hx::IsNull( font )) {
HXLINE( 207)			_hx_tmp = ::flixel::graphics::frames::FlxBitmapFont_obj::getDefaultFont();
            		}
            		else {
HXLINE( 207)			_hx_tmp = font;
            		}
HXDLIN( 207)		this->set_font(_hx_tmp);
HXLINE( 209)		 ::flixel::math::FlxPoint point = ::flixel::math::FlxPoint_obj::_pool->get()->set((int)1,(int)1);
HXDLIN( 209)		point->_inPool = false;
HXDLIN( 209)		this->shadowOffset = point;
HXLINE( 211)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 213)			this->set_pixels( ::openfl::_legacy::display::BitmapData_obj::__alloc( HX_CTX ,(int)1,(int)1,true,(int)0,null()));
            		}
            		else {
HXLINE( 217)			this->textData = ::Array_obj< Float >::__new(0);
HXLINE( 219)			this->textDrawData = ::Array_obj< Float >::__new(0);
HXLINE( 220)			this->borderDrawData = ::Array_obj< Float >::__new(0);
            		}
            	}

Dynamic FlxBitmapText_obj::__CreateEmpty() { return new FlxBitmapText_obj; }

void *FlxBitmapText_obj::_hx_vtable = 0;

Dynamic FlxBitmapText_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< FlxBitmapText_obj > _hx_result = new FlxBitmapText_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool FlxBitmapText_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x25a685e0) {
		if (inClassId<=(int)0x0b6ffd77) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x0b6ffd77;
		} else {
			return inClassId==(int)0x25a685e0;
		}
	} else {
		return inClassId==(int)0x2e105115 || inClassId==(int)0x43a521e1;
	}
}

void FlxBitmapText_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_228_destroy)
HXLINE( 229)		this->set_font(null());
HXLINE( 230)		this->set_text(null());
HXLINE( 231)		this->_lines = null();
HXLINE( 232)		this->_linesWidth = null();
HXLINE( 234)		this->shadowOffset = ( ( ::flixel::math::FlxPoint)(::flixel::util::FlxDestroyUtil_obj::put(this->shadowOffset)) );
HXLINE( 235)		this->textBitmap = ::flixel::util::FlxDestroyUtil_obj::dispose(this->textBitmap);
HXLINE( 237)		this->_colorParams = null();
HXLINE( 239)		if (::flixel::FlxG_obj::renderTile) {
HXLINE( 241)			this->textData = null();
HXLINE( 242)			this->textDrawData = null();
HXLINE( 243)			this->borderDrawData = null();
            		}
HXLINE( 245)		this->super::destroy();
            	}


void FlxBitmapText_obj::drawFrame(hx::Null< bool >  __o_Force){
bool Force = __o_Force.Default(false);
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_252_drawFrame)
HXLINE( 253)		if (::flixel::FlxG_obj::renderTile) {
HXLINE( 255)			Force = true;
            		}
HXLINE( 257)		bool _hx_tmp;
HXDLIN( 257)		if (!(this->pendingTextBitmapChange)) {
HXLINE( 257)			_hx_tmp = Force;
            		}
            		else {
HXLINE( 257)			_hx_tmp = true;
            		}
HXDLIN( 257)		this->pendingTextBitmapChange = _hx_tmp;
HXLINE( 258)		{
HXLINE( 258)			bool useTiles = false;
HXDLIN( 258)			if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 258)				useTiles = false;
            			}
HXDLIN( 258)			if (this->pendingTextChange) {
HXLINE( 258)				this->updateText();
HXDLIN( 258)				this->pendingTextBitmapChange = true;
            			}
HXDLIN( 258)			if (this->pendingTextBitmapChange) {
HXLINE( 258)				this->updateTextBitmap(useTiles);
HXDLIN( 258)				this->pendingPixelsChange = true;
            			}
HXDLIN( 258)			if (this->pendingPixelsChange) {
HXLINE( 258)				this->updatePixels(useTiles);
            			}
            		}
HXLINE( 259)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 261)			this->super::drawFrame(Force);
            		}
            	}


void FlxBitmapText_obj::checkPendingChanges(hx::Null< bool >  __o_useTiles){
bool useTiles = __o_useTiles.Default(false);
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_266_checkPendingChanges)
HXLINE( 267)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 269)			useTiles = false;
            		}
HXLINE( 272)		if (this->pendingTextChange) {
HXLINE( 274)			this->updateText();
HXLINE( 275)			this->pendingTextBitmapChange = true;
            		}
HXLINE( 278)		if (this->pendingTextBitmapChange) {
HXLINE( 280)			this->updateTextBitmap(useTiles);
HXLINE( 281)			this->pendingPixelsChange = true;
            		}
HXLINE( 284)		if (this->pendingPixelsChange) {
HXLINE( 286)			this->updatePixels(useTiles);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,checkPendingChanges,(void))

void FlxBitmapText_obj::draw(){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_292_draw)
HXDLIN( 292)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 294)			{
HXLINE( 294)				bool useTiles = false;
HXDLIN( 294)				if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 294)					useTiles = false;
            				}
HXDLIN( 294)				if (this->pendingTextChange) {
HXLINE( 294)					this->updateText();
HXDLIN( 294)					this->pendingTextBitmapChange = true;
            				}
HXDLIN( 294)				if (this->pendingTextBitmapChange) {
HXLINE( 294)					this->updateTextBitmap(useTiles);
HXDLIN( 294)					this->pendingPixelsChange = true;
            				}
HXDLIN( 294)				if (this->pendingPixelsChange) {
HXLINE( 294)					this->updatePixels(useTiles);
            				}
            			}
HXLINE( 295)			this->super::draw();
            		}
            		else {
HXLINE( 299)			{
HXLINE( 299)				bool useTiles1 = true;
HXDLIN( 299)				if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 299)					useTiles1 = false;
            				}
HXDLIN( 299)				if (this->pendingTextChange) {
HXLINE( 299)					this->updateText();
HXDLIN( 299)					this->pendingTextBitmapChange = true;
            				}
HXDLIN( 299)				if (this->pendingTextBitmapChange) {
HXLINE( 299)					this->updateTextBitmap(useTiles1);
HXDLIN( 299)					this->pendingPixelsChange = true;
            				}
HXDLIN( 299)				if (this->pendingPixelsChange) {
HXLINE( 299)					this->updatePixels(useTiles1);
            				}
            			}
HXLINE( 301)			int textLength = ::Std_obj::_hx_int(((Float)this->textDrawData->length / (Float)(int)3));
HXLINE( 302)			int borderLength = ::Std_obj::_hx_int(((Float)this->borderDrawData->length / (Float)(int)3));
HXLINE( 304)			int dataPos;
HXLINE( 306)			Float cr = ((Float)((int)((int)this->color >> (int)(int)16) & (int)(int)255) / (Float)(int)255);
HXLINE( 307)			Float cg = ((Float)((int)((int)this->color >> (int)(int)8) & (int)(int)255) / (Float)(int)255);
HXLINE( 308)			Float cb = ((Float)((int)this->color & (int)(int)255) / (Float)(int)255);
HXLINE( 310)			Float borderRed = (((Float)((int)((int)this->borderColor >> (int)(int)16) & (int)(int)255) / (Float)(int)255) * cr);
HXLINE( 311)			Float borderGreen = (((Float)((int)((int)this->borderColor >> (int)(int)8) & (int)(int)255) / (Float)(int)255) * cg);
HXLINE( 312)			Float borderBlue = (((Float)((int)this->borderColor & (int)(int)255) / (Float)(int)255) * cb);
HXLINE( 313)			Float bAlpha = (((Float)((int)((int)this->borderColor >> (int)(int)24) & (int)(int)255) / (Float)(int)255) * this->alpha);
HXLINE( 315)			Float textRed = cr;
HXLINE( 316)			Float textGreen = cg;
HXLINE( 317)			Float textBlue = cb;
HXLINE( 318)			Float tAlpha = this->alpha;
HXLINE( 320)			if (this->useTextColor) {
HXLINE( 322)				textRed = (textRed * ((Float)((int)((int)this->textColor >> (int)(int)16) & (int)(int)255) / (Float)(int)255));
HXLINE( 323)				textGreen = (textGreen * ((Float)((int)((int)this->textColor >> (int)(int)8) & (int)(int)255) / (Float)(int)255));
HXLINE( 324)				textBlue = (textBlue * ((Float)((int)this->textColor & (int)(int)255) / (Float)(int)255));
HXLINE( 325)				tAlpha = (tAlpha * ((int)((int)this->textColor >> (int)(int)24) & (int)(int)255));
            			}
HXLINE( 328)			Float bgRed = cr;
HXLINE( 329)			Float bgGreen = cg;
HXLINE( 330)			Float bgBlue = cb;
HXLINE( 331)			Float bgAlpha = this->alpha;
HXLINE( 333)			if (this->background) {
HXLINE( 335)				bgRed = (bgRed * ((Float)((int)((int)this->backgroundColor >> (int)(int)16) & (int)(int)255) / (Float)(int)255));
HXLINE( 336)				bgGreen = (bgGreen * ((Float)((int)((int)this->backgroundColor >> (int)(int)8) & (int)(int)255) / (Float)(int)255));
HXLINE( 337)				bgBlue = (bgBlue * ((Float)((int)this->backgroundColor & (int)(int)255) / (Float)(int)255));
HXLINE( 338)				bgAlpha = (bgAlpha * ((Float)((int)((int)this->backgroundColor >> (int)(int)24) & (int)(int)255) / (Float)(int)255));
            			}
HXLINE( 341)			 ::flixel::graphics::tile::FlxDrawTilesItem drawItem;
HXLINE( 342)			 ::flixel::graphics::frames::FlxFrame currFrame = null();
HXLINE( 343)			Float currTileX = (int)0;
HXLINE( 344)			Float currTileY = (int)0;
HXLINE( 345)			Float sx = (this->scale->x * this->_facingHorizontalMult);
HXLINE( 346)			Float sy = (this->scale->y * this->_facingVerticalMult);
HXLINE( 348)			Float ox = this->origin->x;
HXLINE( 349)			Float oy = this->origin->y;
HXLINE( 351)			if ((this->_facingHorizontalMult != (int)1)) {
HXLINE( 353)				ox = (this->frameWidth - ox);
            			}
HXLINE( 355)			if ((this->_facingVerticalMult != (int)1)) {
HXLINE( 357)				oy = (this->frameHeight - oy);
            			}
HXLINE( 360)			{
HXLINE( 360)				int _g = (int)0;
HXDLIN( 360)				::Array< ::Dynamic> _g1 = this->get_cameras();
HXDLIN( 360)				while((_g < _g1->length)){
HXLINE( 360)					 ::flixel::FlxCamera camera = _g1->__get(_g).StaticCast<  ::flixel::FlxCamera >();
HXDLIN( 360)					_g = (_g + (int)1);
HXLINE( 362)					bool _hx_tmp;
HXDLIN( 362)					bool _hx_tmp1;
HXDLIN( 362)					if (!(!(camera->visible))) {
HXLINE( 362)						_hx_tmp1 = !(camera->exists);
            					}
            					else {
HXLINE( 362)						_hx_tmp1 = true;
            					}
HXDLIN( 362)					if (!(_hx_tmp1)) {
HXLINE( 362)						_hx_tmp = !(this->isOnScreen(camera));
            					}
            					else {
HXLINE( 362)						_hx_tmp = true;
            					}
HXDLIN( 362)					if (_hx_tmp) {
HXLINE( 364)						continue;
            					}
HXLINE( 367)					this->getScreenPosition(this->_point,camera)->subtractPoint(this->offset);
HXLINE( 369)					if (this->isPixelPerfectRender(camera)) {
HXLINE( 371)						 ::flixel::math::FlxPoint _this = this->_point;
HXDLIN( 371)						_this->set_x(::Math_obj::floor(_this->x));
HXDLIN( 371)						_this->set_y(::Math_obj::floor(_this->y));
            					}
HXLINE( 374)					if (this->_angleChanged) {
HXLINE( 374)						Float radians = this->angle;
HXDLIN( 374)						Float radians1 = (radians * ((Float)::Math_obj::PI / (Float)(int)180));
HXDLIN( 374)						this->_sinAngle = ::Math_obj::sin(radians1);
HXDLIN( 374)						this->_cosAngle = ::Math_obj::cos(radians1);
HXDLIN( 374)						this->_angleChanged = false;
            					}
HXLINE( 376)					if (this->background) {
HXLINE( 379)						currFrame = ::flixel::FlxG_obj::bitmap->get_whitePixel();
HXLINE( 380)						this->_matrix->identity();
HXLINE( 381)						 ::flixel::math::FlxMatrix _hx_tmp2 = this->_matrix;
HXDLIN( 381)						Float _hx_tmp3 = (((Float)0.1) * this->frameWidth);
HXDLIN( 381)						_hx_tmp2->scale(_hx_tmp3,(((Float)0.1) * this->frameHeight));
HXLINE( 382)						this->_matrix->translate(-(ox),-(oy));
HXLINE( 383)						this->_matrix->scale(sx,sy);
HXLINE( 385)						if ((this->angle != (int)0)) {
HXLINE( 387)							 ::flixel::math::FlxMatrix _this1 = this->_matrix;
HXDLIN( 387)							Float cos = this->_cosAngle;
HXDLIN( 387)							Float sin = this->_sinAngle;
HXDLIN( 387)							Float a1 = (_this1->a * cos);
HXDLIN( 387)							Float a11 = (a1 - (_this1->b * sin));
HXDLIN( 387)							Float _hx_tmp4 = (_this1->a * sin);
HXDLIN( 387)							_this1->b = (_hx_tmp4 + (_this1->b * cos));
HXDLIN( 387)							_this1->a = a11;
HXDLIN( 387)							Float c1 = (_this1->c * cos);
HXDLIN( 387)							Float c11 = (c1 - (_this1->d * sin));
HXDLIN( 387)							Float _hx_tmp5 = (_this1->c * sin);
HXDLIN( 387)							_this1->d = (_hx_tmp5 + (_this1->d * cos));
HXDLIN( 387)							_this1->c = c11;
HXDLIN( 387)							Float tx1 = (_this1->tx * cos);
HXDLIN( 387)							Float tx11 = (tx1 - (_this1->ty * sin));
HXDLIN( 387)							Float _hx_tmp6 = (_this1->tx * sin);
HXDLIN( 387)							_this1->ty = (_hx_tmp6 + (_this1->ty * cos));
HXDLIN( 387)							_this1->tx = tx11;
            						}
HXLINE( 390)						 ::flixel::math::FlxMatrix _hx_tmp7 = this->_matrix;
HXDLIN( 390)						Float _hx_tmp8 = (this->_point->x + ox);
HXDLIN( 390)						_hx_tmp7->translate(_hx_tmp8,(this->_point->y + oy));
HXLINE( 391)						::flixel::util::FlxColorTransformUtil_obj::setMultipliers(this->_colorParams,bgRed,bgGreen,bgBlue,bgAlpha);
HXLINE( 392)						camera->drawPixels(currFrame,null(),this->_matrix,this->_colorParams,this->blend,this->antialiasing,null());
            					}
HXLINE( 395)					bool hasColorOffsets;
HXDLIN( 395)					if (hx::IsNotNull( this->colorTransform )) {
HXLINE( 395)						hasColorOffsets = ::flixel::util::FlxColorTransformUtil_obj::hasRGBAOffsets(this->colorTransform);
            					}
            					else {
HXLINE( 395)						hasColorOffsets = false;
            					}
HXLINE( 397)					drawItem = camera->startQuadBatch(this->font->parent,true,hasColorOffsets,this->blend,this->antialiasing,this->shader);
HXLINE( 399)					{
HXLINE( 399)						int _g3 = (int)0;
HXDLIN( 399)						int _g2 = borderLength;
HXDLIN( 399)						while((_g3 < _g2)){
HXLINE( 399)							_g3 = (_g3 + (int)1);
HXDLIN( 399)							int j = (_g3 - (int)1);
HXLINE( 401)							dataPos = (j * (int)3);
HXLINE( 403)							 ::flixel::graphics::frames::FlxBitmapFont _this2 = this->font;
HXDLIN( 403)							int charCode = ::Std_obj::_hx_int(this->borderDrawData->__get(dataPos));
HXDLIN( 403)							currFrame = ( ( ::flixel::graphics::frames::FlxFrame)(::haxe::IMap_obj::get(_this2->charMap,charCode)) );
HXLINE( 405)							::Array< Float > currTileX1 = this->borderDrawData;
HXDLIN( 405)							currTileX = currTileX1->__get((dataPos + (int)1));
HXLINE( 406)							::Array< Float > currTileY1 = this->borderDrawData;
HXDLIN( 406)							currTileY = currTileY1->__get((dataPos + (int)2));
HXLINE( 408)							currFrame->prepareMatrix(this->_matrix,null(),null(),null());
HXLINE( 409)							 ::flixel::math::FlxMatrix _hx_tmp9 = this->_matrix;
HXDLIN( 409)							_hx_tmp9->translate((currTileX - ox),(currTileY - oy));
HXLINE( 410)							this->_matrix->scale(sx,sy);
HXLINE( 411)							if ((this->angle != (int)0)) {
HXLINE( 413)								 ::flixel::math::FlxMatrix _this3 = this->_matrix;
HXDLIN( 413)								Float cos1 = this->_cosAngle;
HXDLIN( 413)								Float sin1 = this->_sinAngle;
HXDLIN( 413)								Float a12 = (_this3->a * cos1);
HXDLIN( 413)								Float a13 = (a12 - (_this3->b * sin1));
HXDLIN( 413)								Float _hx_tmp10 = (_this3->a * sin1);
HXDLIN( 413)								_this3->b = (_hx_tmp10 + (_this3->b * cos1));
HXDLIN( 413)								_this3->a = a13;
HXDLIN( 413)								Float c12 = (_this3->c * cos1);
HXDLIN( 413)								Float c13 = (c12 - (_this3->d * sin1));
HXDLIN( 413)								Float _hx_tmp11 = (_this3->c * sin1);
HXDLIN( 413)								_this3->d = (_hx_tmp11 + (_this3->d * cos1));
HXDLIN( 413)								_this3->c = c13;
HXDLIN( 413)								Float tx12 = (_this3->tx * cos1);
HXDLIN( 413)								Float tx13 = (tx12 - (_this3->ty * sin1));
HXDLIN( 413)								Float _hx_tmp12 = (_this3->tx * sin1);
HXDLIN( 413)								_this3->ty = (_hx_tmp12 + (_this3->ty * cos1));
HXDLIN( 413)								_this3->tx = tx13;
            							}
HXLINE( 416)							 ::flixel::math::FlxMatrix _hx_tmp13 = this->_matrix;
HXDLIN( 416)							Float _hx_tmp14 = (this->_point->x + ox);
HXDLIN( 416)							_hx_tmp13->translate(_hx_tmp14,(this->_point->y + oy));
HXLINE( 417)							::flixel::util::FlxColorTransformUtil_obj::setMultipliers(this->_colorParams,borderRed,borderGreen,borderBlue,bAlpha);
HXLINE( 418)							drawItem->addQuad(currFrame,this->_matrix,this->_colorParams);
            						}
            					}
HXLINE( 421)					{
HXLINE( 421)						int _g31 = (int)0;
HXDLIN( 421)						int _g21 = textLength;
HXDLIN( 421)						while((_g31 < _g21)){
HXLINE( 421)							_g31 = (_g31 + (int)1);
HXDLIN( 421)							int j1 = (_g31 - (int)1);
HXLINE( 423)							dataPos = (j1 * (int)3);
HXLINE( 425)							 ::flixel::graphics::frames::FlxBitmapFont _this4 = this->font;
HXDLIN( 425)							int charCode1 = ::Std_obj::_hx_int(this->textDrawData->__get(dataPos));
HXDLIN( 425)							currFrame = ( ( ::flixel::graphics::frames::FlxFrame)(::haxe::IMap_obj::get(_this4->charMap,charCode1)) );
HXLINE( 427)							::Array< Float > currTileX2 = this->textDrawData;
HXDLIN( 427)							currTileX = currTileX2->__get((dataPos + (int)1));
HXLINE( 428)							::Array< Float > currTileY2 = this->textDrawData;
HXDLIN( 428)							currTileY = currTileY2->__get((dataPos + (int)2));
HXLINE( 430)							currFrame->prepareMatrix(this->_matrix,null(),null(),null());
HXLINE( 431)							 ::flixel::math::FlxMatrix _hx_tmp15 = this->_matrix;
HXDLIN( 431)							_hx_tmp15->translate((currTileX - ox),(currTileY - oy));
HXLINE( 432)							this->_matrix->scale(sx,sy);
HXLINE( 433)							if ((this->angle != (int)0)) {
HXLINE( 435)								 ::flixel::math::FlxMatrix _this5 = this->_matrix;
HXDLIN( 435)								Float cos2 = this->_cosAngle;
HXDLIN( 435)								Float sin2 = this->_sinAngle;
HXDLIN( 435)								Float a14 = (_this5->a * cos2);
HXDLIN( 435)								Float a15 = (a14 - (_this5->b * sin2));
HXDLIN( 435)								Float _hx_tmp16 = (_this5->a * sin2);
HXDLIN( 435)								_this5->b = (_hx_tmp16 + (_this5->b * cos2));
HXDLIN( 435)								_this5->a = a15;
HXDLIN( 435)								Float c14 = (_this5->c * cos2);
HXDLIN( 435)								Float c15 = (c14 - (_this5->d * sin2));
HXDLIN( 435)								Float _hx_tmp17 = (_this5->c * sin2);
HXDLIN( 435)								_this5->d = (_hx_tmp17 + (_this5->d * cos2));
HXDLIN( 435)								_this5->c = c15;
HXDLIN( 435)								Float tx14 = (_this5->tx * cos2);
HXDLIN( 435)								Float tx15 = (tx14 - (_this5->ty * sin2));
HXDLIN( 435)								Float _hx_tmp18 = (_this5->tx * sin2);
HXDLIN( 435)								_this5->ty = (_hx_tmp18 + (_this5->ty * cos2));
HXDLIN( 435)								_this5->tx = tx15;
            							}
HXLINE( 438)							 ::flixel::math::FlxMatrix _hx_tmp19 = this->_matrix;
HXDLIN( 438)							Float _hx_tmp20 = (this->_point->x + ox);
HXDLIN( 438)							_hx_tmp19->translate(_hx_tmp20,(this->_point->y + oy));
HXLINE( 440)							::flixel::util::FlxColorTransformUtil_obj::setMultipliers(this->_colorParams,textRed,textGreen,textBlue,tAlpha);
HXLINE( 441)							drawItem->addQuad(currFrame,this->_matrix,this->_colorParams);
            						}
            					}
HXLINE( 445)					::flixel::FlxBasic_obj::visibleCount++;
            				}
            			}
HXLINE( 450)			if (::flixel::FlxG_obj::debugger->drawDebug) {
HXLINE( 452)				this->drawDebug();
            			}
            		}
            	}


int FlxBitmapText_obj::set_color(int Color){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_459_set_color)
HXLINE( 460)		this->super::set_color(Color);
HXLINE( 461)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 463)			this->pendingTextBitmapChange = true;
            		}
HXLINE( 465)		return this->color;
            	}


Float FlxBitmapText_obj::set_alpha(Float value){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_469_set_alpha)
HXLINE( 470)		this->super::set_alpha(value);
HXLINE( 471)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 473)			this->pendingTextBitmapChange = true;
            		}
HXLINE( 475)		return value;
            	}


int FlxBitmapText_obj::set_textColor(int value){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_479_set_textColor)
HXLINE( 480)		if ((this->textColor != value)) {
HXLINE( 482)			this->textColor = value;
HXLINE( 483)			if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 485)				this->pendingPixelsChange = true;
            			}
            		}
HXLINE( 489)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,set_textColor,return )

bool FlxBitmapText_obj::set_useTextColor(bool value){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_493_set_useTextColor)
HXLINE( 494)		if ((this->useTextColor != value)) {
HXLINE( 496)			this->useTextColor = value;
HXLINE( 497)			if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 499)				this->pendingPixelsChange = true;
            			}
            		}
HXLINE( 503)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,set_useTextColor,return )

void FlxBitmapText_obj::calcFrame(hx::Null< bool >  __o_RunOnCpp){
bool RunOnCpp = __o_RunOnCpp.Default(false);
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_508_calcFrame)
HXDLIN( 508)		if (::flixel::FlxG_obj::renderTile) {
HXLINE( 510)			this->drawFrame(RunOnCpp);
            		}
            		else {
HXLINE( 514)			this->super::calcFrame(RunOnCpp);
            		}
            	}


::String FlxBitmapText_obj::set_text(::String value){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_519_set_text)
HXLINE( 520)		if ((value != this->text)) {
HXLINE( 522)			this->text = value;
HXLINE( 523)			this->pendingTextChange = true;
            		}
HXLINE( 526)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,set_text,return )

void FlxBitmapText_obj::updateText(){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_530_updateText)
HXLINE( 531)		::String tmp;
HXDLIN( 531)		if (this->autoUpperCase) {
HXLINE( 531)			tmp = this->text.toUpperCase();
            		}
            		else {
HXLINE( 531)			tmp = this->text;
            		}
HXLINE( 533)		this->_lines = tmp.split(HX_("\n",0a,00,00,00));
HXLINE( 535)		if (!(this->autoSize)) {
HXLINE( 537)			if (this->wordWrap) {
HXLINE( 539)				this->wrap();
            			}
            			else {
HXLINE( 543)				this->cutLines();
            			}
            		}
HXLINE( 547)		if (!(this->multiLine)) {
HXLINE( 549)			this->_lines = ::Array_obj< ::String >::__new(1)->init(0,this->_lines->__get((int)0));
            		}
HXLINE( 552)		int numLines = this->_lines->length;
HXLINE( 553)		{
HXLINE( 553)			int _g1 = (int)0;
HXDLIN( 553)			int _g = numLines;
HXDLIN( 553)			while((_g1 < _g)){
HXLINE( 553)				_g1 = (_g1 + (int)1);
HXDLIN( 553)				int i = (_g1 - (int)1);
HXLINE( 555)				::Array< ::String > _hx_tmp = this->_lines;
HXDLIN( 555)				_hx_tmp[i] = ::StringTools_obj::rtrim(this->_lines->__get(i));
            			}
            		}
HXLINE( 558)		this->pendingTextChange = false;
HXLINE( 559)		this->pendingTextBitmapChange = true;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxBitmapText_obj,updateText,(void))

void FlxBitmapText_obj::computeTextSize(){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_566_computeTextSize)
HXLINE( 567)		int txtWidth = this->get_textWidth();
HXLINE( 568)		int txtHeight = this->get_textHeight();
HXDLIN( 568)		int txtHeight1 = (txtHeight + ((int)2 * this->padding));
HXLINE( 570)		if (this->autoSize) {
HXLINE( 572)			txtWidth = (txtWidth + ((int)2 * this->padding));
            		}
            		else {
HXLINE( 576)			txtWidth = this->get_fieldWidth();
            		}
HXLINE( 579)		int _hx_tmp;
HXDLIN( 579)		if ((txtWidth == (int)0)) {
HXLINE( 579)			_hx_tmp = (int)1;
            		}
            		else {
HXLINE( 579)			_hx_tmp = txtWidth;
            		}
HXDLIN( 579)		this->frameWidth = _hx_tmp;
HXLINE( 580)		int _hx_tmp1;
HXDLIN( 580)		if ((txtHeight1 == (int)0)) {
HXLINE( 580)			_hx_tmp1 = (int)1;
            		}
            		else {
HXLINE( 580)			_hx_tmp1 = txtHeight1;
            		}
HXDLIN( 580)		this->frameHeight = _hx_tmp1;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxBitmapText_obj,computeTextSize,(void))

int FlxBitmapText_obj::getLineWidth(int lineIndex){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_590_getLineWidth)
HXLINE( 591)		bool _hx_tmp;
HXDLIN( 591)		if ((lineIndex >= (int)0)) {
HXLINE( 591)			_hx_tmp = (lineIndex >= this->_lines->length);
            		}
            		else {
HXLINE( 591)			_hx_tmp = true;
            		}
HXDLIN( 591)		if (_hx_tmp) {
HXLINE( 593)			return (int)0;
            		}
HXLINE( 596)		return this->getStringWidth(this->_lines->__get(lineIndex));
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,getLineWidth,return )

int FlxBitmapText_obj::getStringWidth(::String str){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_606_getStringWidth)
HXLINE( 607)		int spaceWidth = this->font->spaceWidth;
HXLINE( 608)		int tabWidth = (spaceWidth * this->numSpacesInTab);
HXLINE( 610)		int lineLength = ::haxe::Utf8_obj::length(str);
HXLINE( 611)		Float lineWidth = this->font->minOffsetX;
HXLINE( 613)		int charCode;
HXLINE( 614)		Float charWidth;
HXLINE( 615)		 ::flixel::graphics::frames::FlxFrame charFrame;
HXLINE( 617)		{
HXLINE( 617)			int _g1 = (int)0;
HXDLIN( 617)			int _g = lineLength;
HXDLIN( 617)			while((_g1 < _g)){
HXLINE( 617)				_g1 = (_g1 + (int)1);
HXDLIN( 617)				int c = (_g1 - (int)1);
HXLINE( 619)				charCode = ::haxe::Utf8_obj::charCodeAt(str,c);
HXLINE( 620)				charWidth = (int)0;
HXLINE( 622)				if ((charCode == (int)32)) {
HXLINE( 624)					charWidth = spaceWidth;
            				}
            				else {
HXLINE( 626)					if ((charCode == (int)9)) {
HXLINE( 628)						charWidth = tabWidth;
            					}
            					else {
HXLINE( 630)						if (::haxe::IMap_obj::exists(this->font->charMap,charCode)) {
HXLINE( 632)							 ::flixel::graphics::frames::FlxBitmapFont _this = this->font;
HXDLIN( 632)							if (::haxe::IMap_obj::exists(_this->charAdvance,charCode)) {
HXLINE( 632)								charWidth = ( (Float)(::haxe::IMap_obj::get(_this->charAdvance,charCode)) );
            							}
            							else {
HXLINE( 632)								charWidth = (int)0;
            							}
HXLINE( 634)							if ((c == (lineLength - (int)1))) {
HXLINE( 636)								charFrame = ( ( ::flixel::graphics::frames::FlxFrame)(::haxe::IMap_obj::get(this->font->charMap,charCode)) );
HXLINE( 637)								charWidth = ::Std_obj::_hx_int(charFrame->sourceSize->x);
            							}
            						}
            					}
            				}
HXLINE( 641)				lineWidth = (lineWidth + (charWidth + this->letterSpacing));
            			}
            		}
HXLINE( 644)		if ((lineLength > (int)0)) {
HXLINE( 646)			lineWidth = (lineWidth - this->letterSpacing);
            		}
HXLINE( 649)		return ::Std_obj::_hx_int(lineWidth);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,getStringWidth,return )

void FlxBitmapText_obj::cutLines(){
            	HX_GC_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_656_cutLines)
HXLINE( 657)		::Array< ::String > newLines = ::Array_obj< ::String >::__new(0);
HXLINE( 659)		int lineLength;
HXLINE( 661)		int c;
HXLINE( 662)		int charCode;
HXLINE( 663)		Float charWidth;
HXLINE( 665)		 ::haxe::Utf8 subLine;
HXLINE( 666)		Float subLineWidth;
HXLINE( 668)		int spaceWidth = this->font->spaceWidth;
HXLINE( 669)		int tabWidth = (spaceWidth * this->numSpacesInTab);
HXLINE( 671)		int startX = this->font->minOffsetX;
HXLINE( 673)		{
HXLINE( 673)			int _g = (int)0;
HXDLIN( 673)			::Array< ::String > _g1 = this->_lines;
HXDLIN( 673)			while((_g < _g1->length)){
HXLINE( 673)				::String line = _g1->__get(_g);
HXDLIN( 673)				_g = (_g + (int)1);
HXLINE( 675)				lineLength = ::haxe::Utf8_obj::length(line);
HXLINE( 676)				subLine =  ::haxe::Utf8_obj::__alloc( HX_CTX ,null());
HXLINE( 677)				subLineWidth = startX;
HXLINE( 679)				c = (int)0;
HXLINE( 680)				while((c < lineLength)){
HXLINE( 682)					charCode = ::haxe::Utf8_obj::charCodeAt(line,c);
HXLINE( 684)					if ((charCode == (int)32)) {
HXLINE( 686)						charWidth = spaceWidth;
            					}
            					else {
HXLINE( 688)						if ((charCode == (int)9)) {
HXLINE( 690)							charWidth = tabWidth;
            						}
            						else {
HXLINE( 694)							 ::flixel::graphics::frames::FlxBitmapFont _this = this->font;
HXDLIN( 694)							if (::haxe::IMap_obj::exists(_this->charAdvance,charCode)) {
HXLINE( 694)								charWidth = ( (Float)(::haxe::IMap_obj::get(_this->charAdvance,charCode)) );
            							}
            							else {
HXLINE( 694)								charWidth = (int)0;
            							}
            						}
            					}
HXLINE( 696)					charWidth = (charWidth + this->letterSpacing);
HXLINE( 698)					int _hx_tmp = this->_fieldWidth;
HXDLIN( 698)					if (((subLineWidth + charWidth) > (_hx_tmp - ((int)2 * this->padding)))) {
HXLINE( 700)						subLine->addChar(charCode);
HXLINE( 701)						newLines->push(subLine->toString());
HXLINE( 702)						subLine =  ::haxe::Utf8_obj::__alloc( HX_CTX ,null());
HXLINE( 703)						subLineWidth = startX;
HXLINE( 704)						c = lineLength;
            					}
            					else {
HXLINE( 708)						subLine->addChar(charCode);
HXLINE( 709)						subLineWidth = (subLineWidth + charWidth);
            					}
HXLINE( 712)					c = (c + (int)1);
            				}
            			}
            		}
HXLINE( 716)		this->_lines = newLines;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxBitmapText_obj,cutLines,(void))

void FlxBitmapText_obj::wrap(){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_724_wrap)
HXLINE( 726)		::Array< ::String > newLines = ::Array_obj< ::String >::__new(0);
HXLINE( 727)		::Array< ::String > words;
HXLINE( 729)		{
HXLINE( 729)			int _g = (int)0;
HXDLIN( 729)			::Array< ::String > _g1 = this->_lines;
HXDLIN( 729)			while((_g < _g1->length)){
HXLINE( 729)				::String line = _g1->__get(_g);
HXDLIN( 729)				_g = (_g + (int)1);
HXLINE( 731)				words = ::Array_obj< ::String >::__new(0);
HXLINE( 733)				this->splitLineIntoWords(line,words);
HXLINE( 735)				if (this->wrapByWord) {
HXLINE( 737)					this->wrapLineByWord(words,newLines);
            				}
            				else {
HXLINE( 741)					this->wrapLineByCharacter(words,newLines);
            				}
            			}
            		}
HXLINE( 745)		this->_lines = newLines;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxBitmapText_obj,wrap,(void))

void FlxBitmapText_obj::splitLineIntoWords(::String line,::Array< ::String > words){
            	HX_GC_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_755_splitLineIntoWords)
HXLINE( 756)		::String word = HX_("",00,00,00,00);
HXLINE( 757)		 ::haxe::Utf8 wordUtf8 =  ::haxe::Utf8_obj::__alloc( HX_CTX ,null());
HXLINE( 758)		bool isSpaceWord = false;
HXLINE( 759)		int lineLength = ::haxe::Utf8_obj::length(line);
HXLINE( 761)		int hyphenCode = ::haxe::Utf8_obj::charCodeAt(HX_("-",2d,00,00,00),(int)0);
HXLINE( 763)		int c = (int)0;
HXLINE( 764)		int charCode;
HXLINE( 765)		 ::haxe::Utf8 charUtf8;
HXLINE( 767)		while((c < lineLength)){
HXLINE( 769)			charCode = ::haxe::Utf8_obj::charCodeAt(line,c);
HXLINE( 770)			word = wordUtf8->toString();
HXLINE( 772)			bool _hx_tmp;
HXDLIN( 772)			if ((charCode != (int)32)) {
HXLINE( 772)				_hx_tmp = (charCode == (int)9);
            			}
            			else {
HXLINE( 772)				_hx_tmp = true;
            			}
HXDLIN( 772)			if (_hx_tmp) {
HXLINE( 774)				if (!(isSpaceWord)) {
HXLINE( 776)					isSpaceWord = true;
HXLINE( 778)					if ((word != HX_("",00,00,00,00))) {
HXLINE( 780)						words->push(word);
HXLINE( 781)						wordUtf8 =  ::haxe::Utf8_obj::__alloc( HX_CTX ,null());
            					}
            				}
HXLINE( 785)				wordUtf8->addChar(charCode);
            			}
            			else {
HXLINE( 787)				if ((charCode == hyphenCode)) {
HXLINE( 789)					bool _hx_tmp1;
HXDLIN( 789)					if (isSpaceWord) {
HXLINE( 789)						_hx_tmp1 = (word != HX_("",00,00,00,00));
            					}
            					else {
HXLINE( 789)						_hx_tmp1 = false;
            					}
HXDLIN( 789)					if (_hx_tmp1) {
HXLINE( 791)						isSpaceWord = false;
HXLINE( 792)						words->push(word);
HXLINE( 793)						words->push(HX_("-",2d,00,00,00));
            					}
            					else {
HXLINE( 795)						if (!(isSpaceWord)) {
HXLINE( 797)							charUtf8 =  ::haxe::Utf8_obj::__alloc( HX_CTX ,null());
HXLINE( 798)							charUtf8->addChar(charCode);
HXLINE( 799)							words->push((word + charUtf8->toString()));
            						}
            					}
HXLINE( 802)					wordUtf8 =  ::haxe::Utf8_obj::__alloc( HX_CTX ,null());
            				}
            				else {
HXLINE( 806)					bool _hx_tmp2;
HXDLIN( 806)					if (isSpaceWord) {
HXLINE( 806)						_hx_tmp2 = (word != HX_("",00,00,00,00));
            					}
            					else {
HXLINE( 806)						_hx_tmp2 = false;
            					}
HXDLIN( 806)					if (_hx_tmp2) {
HXLINE( 808)						isSpaceWord = false;
HXLINE( 809)						words->push(word);
HXLINE( 810)						wordUtf8 =  ::haxe::Utf8_obj::__alloc( HX_CTX ,null());
            					}
HXLINE( 813)					wordUtf8->addChar(charCode);
            				}
            			}
HXLINE( 816)			c = (c + (int)1);
            		}
HXLINE( 819)		word = wordUtf8->toString();
HXLINE( 820)		if ((word != HX_("",00,00,00,00))) {
HXLINE( 820)			words->push(word);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxBitmapText_obj,splitLineIntoWords,(void))

void FlxBitmapText_obj::wrapLineByWord(::Array< ::String > words,::Array< ::String > newLines){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_830_wrapLineByWord)
HXLINE( 831)		int numWords = words->length;
HXLINE( 832)		int w;
HXLINE( 833)		::String word;
HXLINE( 834)		Float wordWidth;
HXLINE( 835)		int wordLength;
HXLINE( 837)		bool isSpaceWord = false;
HXLINE( 839)		int charCode;
HXLINE( 840)		Float charWidth = (int)0;
HXLINE( 842)		::Array< ::String > subLines = ::Array_obj< ::String >::__new(0);
HXLINE( 844)		::String subLine;
HXLINE( 845)		Float subLineWidth;
HXLINE( 847)		int spaceWidth = this->font->spaceWidth;
HXLINE( 848)		int tabWidth = (spaceWidth * this->numSpacesInTab);
HXLINE( 850)		int startX = this->font->minOffsetX;
HXLINE( 852)		if ((numWords > (int)0)) {
HXLINE( 854)			w = (int)0;
HXLINE( 855)			subLineWidth = startX;
HXLINE( 856)			subLine = HX_("",00,00,00,00);
HXLINE( 858)			while((w < numWords)){
HXLINE( 860)				wordWidth = (int)0;
HXLINE( 861)				word = words->__get(w);
HXLINE( 862)				wordLength = ::haxe::Utf8_obj::length(word);
HXLINE( 864)				charCode = ::haxe::Utf8_obj::charCodeAt(word,(int)0);
HXLINE( 865)				if ((charCode != (int)32)) {
HXLINE( 865)					isSpaceWord = (charCode == (int)9);
            				}
            				else {
HXLINE( 865)					isSpaceWord = true;
            				}
HXLINE( 867)				{
HXLINE( 867)					int _g1 = (int)0;
HXDLIN( 867)					int _g = wordLength;
HXDLIN( 867)					while((_g1 < _g)){
HXLINE( 867)						_g1 = (_g1 + (int)1);
HXDLIN( 867)						int c = (_g1 - (int)1);
HXLINE( 869)						charCode = ::haxe::Utf8_obj::charCodeAt(word,c);
HXLINE( 871)						if ((charCode == (int)32)) {
HXLINE( 873)							charWidth = spaceWidth;
            						}
            						else {
HXLINE( 875)							if ((charCode == (int)9)) {
HXLINE( 877)								charWidth = tabWidth;
            							}
            							else {
HXLINE( 881)								 ::flixel::graphics::frames::FlxBitmapFont _this = this->font;
HXDLIN( 881)								if (::haxe::IMap_obj::exists(_this->charAdvance,charCode)) {
HXLINE( 881)									charWidth = ( (Float)(::haxe::IMap_obj::get(_this->charAdvance,charCode)) );
            								}
            								else {
HXLINE( 881)									charWidth = (int)0;
            								}
            							}
            						}
HXLINE( 884)						wordWidth = (wordWidth + charWidth);
            					}
            				}
HXLINE( 887)				wordWidth = (wordWidth + ((wordLength - (int)1) * this->letterSpacing));
HXLINE( 889)				int _hx_tmp = this->_fieldWidth;
HXDLIN( 889)				if (((subLineWidth + wordWidth) > (_hx_tmp - ((int)2 * this->padding)))) {
HXLINE( 891)					if (isSpaceWord) {
HXLINE( 893)						subLines->push(subLine);
HXLINE( 894)						subLine = HX_("",00,00,00,00);
HXLINE( 895)						subLineWidth = startX;
            					}
            					else {
HXLINE( 897)						if ((subLine != HX_("",00,00,00,00))) {
HXLINE( 899)							subLines->push(subLine);
HXLINE( 900)							subLine = word;
HXLINE( 901)							subLineWidth = ((startX + wordWidth) + this->letterSpacing);
            						}
            						else {
HXLINE( 905)							subLine = word;
HXLINE( 906)							subLineWidth = ((startX + wordWidth) + this->letterSpacing);
            						}
            					}
            				}
            				else {
HXLINE( 911)					subLine = (subLine + word);
HXLINE( 912)					subLineWidth = (subLineWidth + (wordWidth + this->letterSpacing));
            				}
HXLINE( 915)				w = (w + (int)1);
            			}
HXLINE( 918)			if ((subLine != HX_("",00,00,00,00))) {
HXLINE( 920)				subLines->push(subLine);
            			}
            		}
HXLINE( 924)		{
HXLINE( 924)			int _g2 = (int)0;
HXDLIN( 924)			while((_g2 < subLines->length)){
HXLINE( 924)				::String subline = subLines->__get(_g2);
HXDLIN( 924)				_g2 = (_g2 + (int)1);
HXLINE( 926)				newLines->push(subline);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxBitmapText_obj,wrapLineByWord,(void))

void FlxBitmapText_obj::wrapLineByCharacter(::Array< ::String > words,::Array< ::String > newLines){
            	HX_GC_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_937_wrapLineByCharacter)
HXLINE( 938)		int numWords = words->length;
HXLINE( 939)		int w;
HXLINE( 940)		::String word;
HXLINE( 941)		int wordLength;
HXLINE( 943)		bool isSpaceWord = false;
HXLINE( 945)		int charCode;
HXLINE( 946)		int c;
HXLINE( 947)		Float charWidth = (int)0;
HXLINE( 949)		::Array< ::String > subLines = ::Array_obj< ::String >::__new(0);
HXLINE( 951)		::String subLine;
HXLINE( 952)		 ::haxe::Utf8 subLineUtf8;
HXLINE( 953)		Float subLineWidth;
HXLINE( 955)		int spaceWidth = this->font->spaceWidth;
HXLINE( 956)		int tabWidth = (spaceWidth * this->numSpacesInTab);
HXLINE( 958)		int startX = this->font->minOffsetX;
HXLINE( 960)		if ((numWords > (int)0)) {
HXLINE( 962)			w = (int)0;
HXLINE( 963)			subLineWidth = startX;
HXLINE( 964)			subLineUtf8 =  ::haxe::Utf8_obj::__alloc( HX_CTX ,null());
HXLINE( 966)			while((w < numWords)){
HXLINE( 968)				word = words->__get(w);
HXLINE( 969)				wordLength = ::haxe::Utf8_obj::length(word);
HXLINE( 971)				charCode = ::haxe::Utf8_obj::charCodeAt(word,(int)0);
HXLINE( 972)				if ((charCode != (int)32)) {
HXLINE( 972)					isSpaceWord = (charCode == (int)9);
            				}
            				else {
HXLINE( 972)					isSpaceWord = true;
            				}
HXLINE( 974)				c = (int)0;
HXLINE( 976)				while((c < wordLength)){
HXLINE( 978)					charCode = ::haxe::Utf8_obj::charCodeAt(word,c);
HXLINE( 980)					if ((charCode == (int)32)) {
HXLINE( 982)						charWidth = spaceWidth;
            					}
            					else {
HXLINE( 984)						if ((charCode == (int)9)) {
HXLINE( 986)							charWidth = tabWidth;
            						}
            						else {
HXLINE( 990)							 ::flixel::graphics::frames::FlxBitmapFont _this = this->font;
HXDLIN( 990)							if (::haxe::IMap_obj::exists(_this->charAdvance,charCode)) {
HXLINE( 990)								charWidth = ( (Float)(::haxe::IMap_obj::get(_this->charAdvance,charCode)) );
            							}
            							else {
HXLINE( 990)								charWidth = (int)0;
            							}
            						}
            					}
HXLINE( 993)					int _hx_tmp = this->_fieldWidth;
HXDLIN( 993)					if (((subLineWidth + charWidth) > (_hx_tmp - ((int)2 * this->padding)))) {
HXLINE( 995)						subLine = subLineUtf8->toString();
HXLINE( 997)						if (isSpaceWord) {
HXLINE( 999)							subLines->push(subLine);
HXLINE(1000)							c = wordLength;
HXLINE(1001)							subLineUtf8 =  ::haxe::Utf8_obj::__alloc( HX_CTX ,null());
HXLINE(1002)							subLineWidth = startX;
            						}
            						else {
HXLINE(1004)							if ((subLine != HX_("",00,00,00,00))) {
HXLINE(1006)								subLines->push(subLine);
HXLINE(1007)								subLineUtf8 =  ::haxe::Utf8_obj::__alloc( HX_CTX ,null());
HXLINE(1008)								subLineUtf8->addChar(charCode);
HXLINE(1009)								subLineWidth = ((startX + charWidth) + this->letterSpacing);
            							}
            							else {
HXLINE(1013)								subLineUtf8 =  ::haxe::Utf8_obj::__alloc( HX_CTX ,null());
HXLINE(1014)								subLineUtf8->addChar(charCode);
HXLINE(1015)								subLineWidth = ((startX + charWidth) + this->letterSpacing);
            							}
            						}
            					}
            					else {
HXLINE(1020)						subLineUtf8->addChar(charCode);
HXLINE(1021)						subLineWidth = (subLineWidth + (charWidth + this->letterSpacing));
            					}
HXLINE(1024)					c = (c + (int)1);
            				}
HXLINE(1027)				w = (w + (int)1);
            			}
HXLINE(1030)			subLine = subLineUtf8->toString();
HXLINE(1032)			if ((subLine != HX_("",00,00,00,00))) {
HXLINE(1034)				subLines->push(subLine);
            			}
            		}
HXLINE(1038)		{
HXLINE(1038)			int _g = (int)0;
HXDLIN(1038)			while((_g < subLines->length)){
HXLINE(1038)				::String subline = subLines->__get(_g);
HXDLIN(1038)				_g = (_g + (int)1);
HXLINE(1040)				newLines->push(subline);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxBitmapText_obj,wrapLineByCharacter,(void))

void FlxBitmapText_obj::updateTextBitmap(hx::Null< bool >  __o_useTiles){
bool useTiles = __o_useTiles.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1048_updateTextBitmap)
HXLINE(1049)		this->computeTextSize();
HXLINE(1051)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE(1053)			useTiles = false;
            		}
HXLINE(1056)		if (!(useTiles)) {
HXLINE(1058)			this->textBitmap = ::flixel::util::FlxDestroyUtil_obj::disposeIfNotEqual(this->textBitmap,this->frameWidth,this->frameHeight);
HXLINE(1060)			if (hx::IsNull( this->textBitmap )) {
HXLINE(1062)				this->textBitmap =  ::openfl::_legacy::display::BitmapData_obj::__alloc( HX_CTX ,this->frameWidth,this->frameHeight,true,(int)0,null());
            			}
            			else {
HXLINE(1066)				 ::openfl::_legacy::display::BitmapData _hx_tmp = this->textBitmap;
HXDLIN(1066)				_hx_tmp->fillRect(this->textBitmap->get_rect(),(int)0);
            			}
HXLINE(1069)			this->textBitmap->lock();
            		}
            		else {
HXLINE(1071)			if (::flixel::FlxG_obj::renderTile) {
HXLINE(1073)				this->textData->removeRange((int)0,this->textData->length);
            			}
            		}
HXLINE(1076)		this->_fieldWidth = this->frameWidth;
HXLINE(1078)		int numLines = this->_lines->length;
HXLINE(1079)		::String line;
HXLINE(1080)		int lineWidth;
HXLINE(1082)		int ox;
HXDLIN(1082)		int oy;
HXLINE(1084)		{
HXLINE(1084)			int _g1 = (int)0;
HXDLIN(1084)			int _g = numLines;
HXDLIN(1084)			while((_g1 < _g)){
HXLINE(1084)				_g1 = (_g1 + (int)1);
HXDLIN(1084)				int i = (_g1 - (int)1);
HXLINE(1086)				line = this->_lines->__get(i);
HXLINE(1087)				lineWidth = this->_linesWidth->__get(i);
HXLINE(1090)				ox = this->font->minOffsetX;
HXLINE(1091)				oy = ((i * (this->font->lineHeight + this->lineSpacing)) + this->padding);
HXLINE(1093)				if ((this->alignment == HX_("center",d5,25,db,05))) {
HXLINE(1095)					ox = (ox + ::Std_obj::_hx_int(((Float)(this->frameWidth - lineWidth) / (Float)(int)2)));
            				}
            				else {
HXLINE(1097)					if ((this->alignment == HX_("right",dc,0b,64,e9))) {
HXLINE(1099)						ox = (ox + ((this->frameWidth - lineWidth) - this->padding));
            					}
            					else {
HXLINE(1103)						ox = (ox + this->padding);
            					}
            				}
HXLINE(1106)				this->drawLine(i,ox,oy,useTiles);
            			}
            		}
HXLINE(1109)		if (!(useTiles)) {
HXLINE(1111)			this->textBitmap->unlock(null());
            		}
HXLINE(1114)		this->pendingTextBitmapChange = false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,updateTextBitmap,(void))

void FlxBitmapText_obj::drawLine(int lineIndex,int posX,int posY,hx::Null< bool >  __o_useTiles){
bool useTiles = __o_useTiles.Default(false);
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1118_drawLine)
HXLINE(1119)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE(1121)			useTiles = false;
            		}
HXLINE(1124)		if (useTiles) {
HXLINE(1126)			this->tileLine(lineIndex,posX,posY);
            		}
            		else {
HXLINE(1130)			this->blitLine(lineIndex,posX,posY);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxBitmapText_obj,drawLine,(void))

void FlxBitmapText_obj::blitLine(int lineIndex,int startX,int startY){
            	HX_GC_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1135_blitLine)
HXLINE(1136)		 ::flixel::graphics::frames::FlxFrame charFrame;
HXLINE(1137)		int charCode;
HXLINE(1138)		Float curX = startX;
HXLINE(1139)		int curY = startY;
HXLINE(1141)		::String line = this->_lines->__get(lineIndex);
HXLINE(1142)		int spaceWidth = this->font->spaceWidth;
HXLINE(1143)		int lineLength = ::haxe::Utf8_obj::length(line);
HXLINE(1144)		int textWidth = this->get_textWidth();
HXLINE(1146)		if ((this->alignment == HX_("justify",50,df,b5,83))) {
HXLINE(1148)			int numSpaces = (int)0;
HXLINE(1150)			{
HXLINE(1150)				int _g1 = (int)0;
HXDLIN(1150)				int _g = lineLength;
HXDLIN(1150)				while((_g1 < _g)){
HXLINE(1150)					_g1 = (_g1 + (int)1);
HXDLIN(1150)					int i = (_g1 - (int)1);
HXLINE(1152)					charCode = ::haxe::Utf8_obj::charCodeAt(line,i);
HXLINE(1154)					if ((charCode == (int)32)) {
HXLINE(1156)						numSpaces = (numSpaces + (int)1);
            					}
            					else {
HXLINE(1158)						if ((charCode == (int)9)) {
HXLINE(1160)							numSpaces = (numSpaces + this->numSpacesInTab);
            						}
            					}
            				}
            			}
HXLINE(1164)			int lineWidth = this->getStringWidth(line);
HXLINE(1165)			int totalSpacesWidth = (numSpaces * this->font->spaceWidth);
HXLINE(1166)			spaceWidth = ::Std_obj::_hx_int(((Float)((textWidth - lineWidth) + totalSpacesWidth) / (Float)numSpaces));
            		}
HXLINE(1169)		int tabWidth = (spaceWidth * this->numSpacesInTab);
HXLINE(1171)		{
HXLINE(1171)			int _g11 = (int)0;
HXDLIN(1171)			int _g2 = lineLength;
HXDLIN(1171)			while((_g11 < _g2)){
HXLINE(1171)				_g11 = (_g11 + (int)1);
HXDLIN(1171)				int i1 = (_g11 - (int)1);
HXLINE(1173)				charCode = ::haxe::Utf8_obj::charCodeAt(line,i1);
HXLINE(1175)				if ((charCode == (int)32)) {
HXLINE(1177)					curX = (curX + spaceWidth);
            				}
            				else {
HXLINE(1179)					if ((charCode == (int)9)) {
HXLINE(1181)						curX = (curX + tabWidth);
            					}
            					else {
HXLINE(1185)						charFrame = ( ( ::flixel::graphics::frames::FlxFrame)(::haxe::IMap_obj::get(this->font->charMap,charCode)) );
HXLINE(1186)						if (hx::IsNotNull( charFrame )) {
HXLINE(1188)							this->_flashPoint->setTo(curX,curY);
HXLINE(1189)							charFrame->paint(this->textBitmap,this->_flashPoint,true,null());
HXLINE(1190)							 ::haxe::Utf8 charUt8 =  ::haxe::Utf8_obj::__alloc( HX_CTX ,null());
HXLINE(1191)							charUt8->addChar(charCode);
HXLINE(1192)							 ::flixel::graphics::frames::FlxBitmapFont _this = this->font;
HXDLIN(1192)							int curX1;
HXDLIN(1192)							if (::haxe::IMap_obj::exists(_this->charAdvance,charCode)) {
HXLINE(1192)								curX1 = ( (int)(::haxe::IMap_obj::get(_this->charAdvance,charCode)) );
            							}
            							else {
HXLINE(1192)								curX1 = (int)0;
            							}
HXDLIN(1192)							curX = (curX + curX1);
            						}
            					}
            				}
HXLINE(1196)				curX = (curX + this->letterSpacing);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxBitmapText_obj,blitLine,(void))

void FlxBitmapText_obj::tileLine(int lineIndex,int startX,int startY){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1201_tileLine)
HXLINE(1202)		if (!(::flixel::FlxG_obj::renderTile)) {
HXLINE(1202)			return;
            		}
HXLINE(1204)		 ::flixel::graphics::frames::FlxFrame charFrame;
HXLINE(1205)		int pos = this->textData->length;
HXLINE(1207)		int charCode;
HXLINE(1208)		Float curX = startX;
HXLINE(1209)		int curY = startY;
HXLINE(1211)		::String line = this->_lines->__get(lineIndex);
HXLINE(1212)		int spaceWidth = this->font->spaceWidth;
HXLINE(1213)		int lineLength = ::haxe::Utf8_obj::length(line);
HXLINE(1214)		int textWidth = this->get_textWidth();
HXLINE(1216)		if ((this->alignment == HX_("justify",50,df,b5,83))) {
HXLINE(1218)			int numSpaces = (int)0;
HXLINE(1220)			{
HXLINE(1220)				int _g1 = (int)0;
HXDLIN(1220)				int _g = lineLength;
HXDLIN(1220)				while((_g1 < _g)){
HXLINE(1220)					_g1 = (_g1 + (int)1);
HXDLIN(1220)					int i = (_g1 - (int)1);
HXLINE(1222)					charCode = ::haxe::Utf8_obj::charCodeAt(line,i);
HXLINE(1224)					if ((charCode == (int)32)) {
HXLINE(1226)						numSpaces = (numSpaces + (int)1);
            					}
            					else {
HXLINE(1228)						if ((charCode == (int)9)) {
HXLINE(1230)							numSpaces = (numSpaces + this->numSpacesInTab);
            						}
            					}
            				}
            			}
HXLINE(1234)			int lineWidth = this->getStringWidth(line);
HXLINE(1235)			int totalSpacesWidth = (numSpaces * this->font->spaceWidth);
HXLINE(1236)			spaceWidth = ::Std_obj::_hx_int(((Float)((textWidth - lineWidth) + totalSpacesWidth) / (Float)numSpaces));
            		}
HXLINE(1239)		int tabWidth = (spaceWidth * this->numSpacesInTab);
HXLINE(1241)		{
HXLINE(1241)			int _g11 = (int)0;
HXDLIN(1241)			int _g2 = lineLength;
HXDLIN(1241)			while((_g11 < _g2)){
HXLINE(1241)				_g11 = (_g11 + (int)1);
HXDLIN(1241)				int i1 = (_g11 - (int)1);
HXLINE(1243)				charCode = ::haxe::Utf8_obj::charCodeAt(line,i1);
HXLINE(1245)				if ((charCode == (int)32)) {
HXLINE(1247)					curX = (curX + spaceWidth);
            				}
            				else {
HXLINE(1249)					if ((charCode == (int)9)) {
HXLINE(1251)						curX = (curX + tabWidth);
            					}
            					else {
HXLINE(1255)						charFrame = ( ( ::flixel::graphics::frames::FlxFrame)(::haxe::IMap_obj::get(this->font->charMap,charCode)) );
HXLINE(1256)						if (hx::IsNotNull( charFrame )) {
HXLINE(1258)							::Array< Float > _hx_tmp = this->textData;
HXDLIN(1258)							pos = (pos + (int)1);
HXDLIN(1258)							_hx_tmp[(pos - (int)1)] = charCode;
HXLINE(1259)							::Array< Float > _hx_tmp1 = this->textData;
HXDLIN(1259)							pos = (pos + (int)1);
HXDLIN(1259)							_hx_tmp1[(pos - (int)1)] = curX;
HXLINE(1260)							::Array< Float > _hx_tmp2 = this->textData;
HXDLIN(1260)							pos = (pos + (int)1);
HXDLIN(1260)							_hx_tmp2[(pos - (int)1)] = curY;
HXLINE(1261)							 ::flixel::graphics::frames::FlxBitmapFont _this = this->font;
HXDLIN(1261)							int curX1;
HXDLIN(1261)							if (::haxe::IMap_obj::exists(_this->charAdvance,charCode)) {
HXLINE(1261)								curX1 = ( (int)(::haxe::IMap_obj::get(_this->charAdvance,charCode)) );
            							}
            							else {
HXLINE(1261)								curX1 = (int)0;
            							}
HXDLIN(1261)							curX = (curX + curX1);
            						}
            					}
            				}
HXLINE(1265)				curX = (curX + this->letterSpacing);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxBitmapText_obj,tileLine,(void))

void FlxBitmapText_obj::updatePixels(hx::Null< bool >  __o_useTiles){
bool useTiles = __o_useTiles.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1270_updatePixels)
HXLINE(1271)		int colorForFill;
HXDLIN(1271)		if (this->background) {
HXLINE(1271)			colorForFill = this->backgroundColor;
            		}
            		else {
HXLINE(1271)			colorForFill = (int)0;
            		}
HXLINE(1272)		 ::openfl::_legacy::display::BitmapData bitmap = null();
HXLINE(1274)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE(1276)			bool _hx_tmp;
HXDLIN(1276)			if (hx::IsNotNull( this->get_pixels() )) {
HXLINE(1276)				int _hx_tmp1 = this->frameWidth;
HXDLIN(1276)				if ((_hx_tmp1 == this->get_pixels()->get_width())) {
HXLINE(1276)					int _hx_tmp2 = this->frameHeight;
HXDLIN(1276)					_hx_tmp = (_hx_tmp2 != this->get_pixels()->get_height());
            				}
            				else {
HXLINE(1276)					_hx_tmp = true;
            				}
            			}
            			else {
HXLINE(1276)				_hx_tmp = true;
            			}
HXDLIN(1276)			if (_hx_tmp) {
HXLINE(1278)				this->set_pixels( ::openfl::_legacy::display::BitmapData_obj::__alloc( HX_CTX ,this->frameWidth,this->frameHeight,true,colorForFill,null()));
            			}
            			else {
HXLINE(1282)				 ::openfl::_legacy::display::BitmapData _hx_tmp3 = this->get_pixels();
HXDLIN(1282)				_hx_tmp3->fillRect(this->graphic->bitmap->get_rect(),colorForFill);
            			}
HXLINE(1285)			bitmap = this->get_pixels();
            		}
            		else {
HXLINE(1289)			if (!(useTiles)) {
HXLINE(1291)				bool _hx_tmp4;
HXDLIN(1291)				if (hx::IsNotNull( this->framePixels )) {
HXLINE(1291)					int _hx_tmp5 = this->frameWidth;
HXDLIN(1291)					if ((_hx_tmp5 == this->framePixels->get_width())) {
HXLINE(1291)						int _hx_tmp6 = this->frameHeight;
HXDLIN(1291)						_hx_tmp4 = (_hx_tmp6 != this->framePixels->get_height());
            					}
            					else {
HXLINE(1291)						_hx_tmp4 = true;
            					}
            				}
            				else {
HXLINE(1291)					_hx_tmp4 = true;
            				}
HXDLIN(1291)				if (_hx_tmp4) {
HXLINE(1293)					this->framePixels = ::flixel::util::FlxDestroyUtil_obj::dispose(this->framePixels);
HXLINE(1294)					this->framePixels =  ::openfl::_legacy::display::BitmapData_obj::__alloc( HX_CTX ,this->frameWidth,this->frameHeight,true,colorForFill,null());
            				}
            				else {
HXLINE(1298)					 ::openfl::_legacy::display::BitmapData _hx_tmp7 = this->framePixels;
HXDLIN(1298)					_hx_tmp7->fillRect(this->framePixels->get_rect(),colorForFill);
            				}
HXLINE(1301)				bitmap = this->framePixels;
            			}
            			else {
HXLINE(1305)				this->textDrawData->removeRange((int)0,this->textDrawData->length);
HXLINE(1306)				this->borderDrawData->removeRange((int)0,this->borderDrawData->length);
            			}
HXLINE(1309)			this->set_width(this->frameWidth);
HXLINE(1310)			this->set_height(this->frameHeight);
HXLINE(1312)			 ::flixel::math::FlxPoint _hx_tmp8 = this->origin;
HXDLIN(1312)			_hx_tmp8->set_x((this->frameWidth * ((Float)0.5)));
HXLINE(1313)			 ::flixel::math::FlxPoint _hx_tmp9 = this->origin;
HXDLIN(1313)			_hx_tmp9->set_y((this->frameHeight * ((Float)0.5)));
            		}
HXLINE(1316)		if (!(useTiles)) {
HXLINE(1318)			bitmap->lock();
            		}
HXLINE(1321)		bool isFront = false;
HXLINE(1323)		int iterations = ::Std_obj::_hx_int((this->borderSize * this->borderQuality));
HXLINE(1324)		if ((iterations <= (int)0)) {
HXLINE(1324)			iterations = (int)1;
            		}
            		else {
HXLINE(1324)			iterations = iterations;
            		}
HXLINE(1326)		int delta = ::Std_obj::_hx_int(((Float)this->borderSize / (Float)iterations));
HXLINE(1328)		int iterationsX = (int)1;
HXLINE(1329)		int iterationsY = (int)1;
HXLINE(1330)		int deltaX = (int)1;
HXLINE(1331)		int deltaY = (int)1;
HXLINE(1333)		if (hx::IsEq( this->borderStyle,::flixel::text::FlxTextBorderStyle_obj::SHADOW_dyn() )) {
HXLINE(1335)			iterationsX = ::Math_obj::round((::Math_obj::abs(this->shadowOffset->x) * this->borderQuality));
HXLINE(1336)			if ((iterationsX <= (int)0)) {
HXLINE(1336)				iterationsX = (int)1;
            			}
            			else {
HXLINE(1336)				iterationsX = iterationsX;
            			}
HXLINE(1338)			iterationsY = ::Math_obj::round((::Math_obj::abs(this->shadowOffset->y) * this->borderQuality));
HXLINE(1339)			if ((iterationsY <= (int)0)) {
HXLINE(1339)				iterationsY = (int)1;
            			}
            			else {
HXLINE(1339)				iterationsY = iterationsY;
            			}
HXLINE(1341)			deltaX = ::Math_obj::round(((Float)this->shadowOffset->x / (Float)iterationsX));
HXLINE(1342)			deltaY = ::Math_obj::round(((Float)this->shadowOffset->y / (Float)iterationsY));
            		}
HXLINE(1346)		{
HXLINE(1346)			 ::flixel::text::FlxTextBorderStyle _g = this->borderStyle;
HXDLIN(1346)			switch((int)(_hx_getEnumValueIndex(_g))){
            				case (int)0: {
            				}
            				break;
            				case (int)1: {
HXLINE(1349)					int _g1 = (int)0;
HXDLIN(1349)					int _g2 = iterationsY;
HXDLIN(1349)					while((_g1 < _g2)){
HXLINE(1349)						_g1 = (_g1 + (int)1);
HXDLIN(1349)						int iterY = (_g1 - (int)1);
HXLINE(1351)						{
HXLINE(1351)							int _g3 = (int)0;
HXDLIN(1351)							int _g21 = iterationsX;
HXDLIN(1351)							while((_g3 < _g21)){
HXLINE(1351)								_g3 = (_g3 + (int)1);
HXDLIN(1351)								int iterX = (_g3 - (int)1);
HXLINE(1353)								this->drawText((deltaX * (iterX + (int)1)),(deltaY * (iterY + (int)1)),isFront,bitmap,useTiles);
            							}
            						}
            					}
            				}
            				break;
            				case (int)2: {
HXLINE(1359)					int itd = (int)0;
HXLINE(1360)					{
HXLINE(1360)						int _g11 = (int)0;
HXDLIN(1360)						int _g4 = iterations;
HXDLIN(1360)						while((_g11 < _g4)){
HXLINE(1360)							_g11 = (_g11 + (int)1);
HXDLIN(1360)							int iter = (_g11 - (int)1);
HXLINE(1362)							itd = (delta * (iter + (int)1));
HXLINE(1364)							this->drawText(-(itd),-(itd),isFront,bitmap,useTiles);
HXLINE(1366)							this->drawText((int)0,-(itd),isFront,bitmap,useTiles);
HXLINE(1368)							this->drawText(itd,-(itd),isFront,bitmap,useTiles);
HXLINE(1370)							this->drawText(-(itd),(int)0,isFront,bitmap,useTiles);
HXLINE(1372)							this->drawText(itd,(int)0,isFront,bitmap,useTiles);
HXLINE(1374)							this->drawText(-(itd),itd,isFront,bitmap,useTiles);
HXLINE(1376)							this->drawText((int)0,itd,isFront,bitmap,useTiles);
HXLINE(1378)							this->drawText(itd,itd,isFront,bitmap,useTiles);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXLINE(1384)					int itd1 = (int)0;
HXLINE(1385)					{
HXLINE(1385)						int _g12 = (int)0;
HXDLIN(1385)						int _g5 = iterations;
HXDLIN(1385)						while((_g12 < _g5)){
HXLINE(1385)							_g12 = (_g12 + (int)1);
HXDLIN(1385)							int iter1 = (_g12 - (int)1);
HXLINE(1387)							itd1 = (delta * (iter1 + (int)1));
HXLINE(1389)							this->drawText(-(itd1),-(itd1),isFront,bitmap,useTiles);
HXLINE(1391)							this->drawText(itd1,-(itd1),isFront,bitmap,useTiles);
HXLINE(1393)							this->drawText(-(itd1),itd1,isFront,bitmap,useTiles);
HXLINE(1395)							this->drawText(itd1,itd1,isFront,bitmap,useTiles);
            						}
            					}
            				}
            				break;
            			}
            		}
HXLINE(1400)		isFront = true;
HXLINE(1401)		this->drawText((int)0,(int)0,isFront,bitmap,useTiles);
HXLINE(1403)		if (!(useTiles)) {
HXLINE(1405)			bitmap->unlock(null());
            		}
HXLINE(1408)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE(1410)			this->dirty = true;
            		}
HXLINE(1413)		this->pendingPixelsChange = false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,updatePixels,(void))

void FlxBitmapText_obj::drawText(int posX,int posY,hx::Null< bool >  __o_isFront, ::openfl::_legacy::display::BitmapData bitmap,hx::Null< bool >  __o_useTiles){
bool isFront = __o_isFront.Default(true);
bool useTiles = __o_useTiles.Default(false);
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1417_drawText)
HXLINE(1418)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE(1420)			useTiles = false;
            		}
HXLINE(1423)		if (useTiles) {
HXLINE(1425)			this->tileText(posX,posY,isFront);
            		}
            		else {
HXLINE(1429)			this->blitText(posX,posY,isFront,bitmap);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(FlxBitmapText_obj,drawText,(void))

void FlxBitmapText_obj::blitText(int posX,int posY,hx::Null< bool >  __o_isFront, ::openfl::_legacy::display::BitmapData bitmap){
bool isFront = __o_isFront.Default(true);
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1434_blitText)
HXLINE(1435)		this->_matrix->identity();
HXLINE(1436)		this->_matrix->translate(posX,posY);
HXLINE(1438)		int colorToApply = (int)-1;
HXLINE(1440)		bool _hx_tmp;
HXDLIN(1440)		if (isFront) {
HXLINE(1440)			_hx_tmp = this->useTextColor;
            		}
            		else {
HXLINE(1440)			_hx_tmp = false;
            		}
HXDLIN(1440)		if (_hx_tmp) {
HXLINE(1442)			colorToApply = this->textColor;
            		}
            		else {
HXLINE(1444)			if (!(isFront)) {
HXLINE(1446)				colorToApply = this->borderColor;
            			}
            		}
HXLINE(1449)		 ::openfl::_legacy::geom::ColorTransform _hx_tmp1 = this->_colorParams;
HXDLIN(1449)		::flixel::util::FlxColorTransformUtil_obj::setMultipliers(_hx_tmp1,((Float)((int)((int)colorToApply >> (int)(int)16) & (int)(int)255) / (Float)(int)255),((Float)((int)((int)colorToApply >> (int)(int)8) & (int)(int)255) / (Float)(int)255),((Float)((int)colorToApply & (int)(int)255) / (Float)(int)255),((Float)((int)((int)colorToApply >> (int)(int)24) & (int)(int)255) / (Float)(int)255));
HXLINE(1453)		bool _hx_tmp2;
HXDLIN(1453)		if (isFront) {
HXLINE(1453)			_hx_tmp2 = !(this->useTextColor);
            		}
            		else {
HXLINE(1453)			_hx_tmp2 = false;
            		}
HXDLIN(1453)		if (_hx_tmp2) {
HXLINE(1455)			 ::openfl::_legacy::geom::Rectangle _hx_tmp3 = this->_flashRect;
HXDLIN(1455)			int _hx_tmp4 = this->textBitmap->get_width();
HXDLIN(1455)			_hx_tmp3->setTo((int)0,(int)0,_hx_tmp4,this->textBitmap->get_height());
HXLINE(1456)			bitmap->copyPixels(this->textBitmap,this->_flashRect,this->_flashPointZero,null(),null(),true);
            		}
            		else {
HXLINE(1460)			bitmap->draw(this->textBitmap,this->_matrix,this->_colorParams,null(),null(),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxBitmapText_obj,blitText,(void))

void FlxBitmapText_obj::tileText(int posX,int posY,hx::Null< bool >  __o_isFront){
bool isFront = __o_isFront.Default(true);
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1465_tileText)
HXLINE(1466)		if (!(::flixel::FlxG_obj::renderTile)) {
HXLINE(1466)			return;
            		}
HXLINE(1468)		::Array< Float > data;
HXDLIN(1468)		if (isFront) {
HXLINE(1468)			data = this->textDrawData;
            		}
            		else {
HXLINE(1468)			data = this->borderDrawData;
            		}
HXLINE(1470)		int pos = data->length;
HXLINE(1471)		int textPos;
HXLINE(1472)		int textLen = ::Std_obj::_hx_int(((Float)this->textData->length / (Float)(int)3));
HXLINE(1474)		{
HXLINE(1474)			int _g1 = (int)0;
HXDLIN(1474)			int _g = textLen;
HXDLIN(1474)			while((_g1 < _g)){
HXLINE(1474)				_g1 = (_g1 + (int)1);
HXDLIN(1474)				int i = (_g1 - (int)1);
HXLINE(1476)				textPos = ((int)3 * i);
HXLINE(1477)				pos = (pos + (int)1);
HXDLIN(1477)				int _hx_tmp = (pos - (int)1);
HXDLIN(1477)				data[_hx_tmp] = this->textData->__get(textPos);
HXLINE(1478)				pos = (pos + (int)1);
HXDLIN(1478)				int _hx_tmp1 = (pos - (int)1);
HXDLIN(1478)				::Array< Float > _hx_tmp2 = this->textData;
HXDLIN(1478)				data[_hx_tmp1] = (_hx_tmp2->__get((textPos + (int)1)) + posX);
HXLINE(1479)				pos = (pos + (int)1);
HXDLIN(1479)				int _hx_tmp3 = (pos - (int)1);
HXDLIN(1479)				::Array< Float > _hx_tmp4 = this->textData;
HXDLIN(1479)				data[_hx_tmp3] = (_hx_tmp4->__get((textPos + (int)2)) + posY);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxBitmapText_obj,tileText,(void))

void FlxBitmapText_obj::setBorderStyle( ::flixel::text::FlxTextBorderStyle Style,hx::Null< int >  __o_Color,hx::Null< Float >  __o_Size,hx::Null< Float >  __o_Quality){
int Color = __o_Color.Default(0);
Float Size = __o_Size.Default(1);
Float Quality = __o_Quality.Default(1);
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1492_setBorderStyle)
HXLINE(1493)		this->set_borderStyle(Style);
HXLINE(1494)		this->set_borderColor(Color);
HXLINE(1495)		this->set_borderSize(Size);
HXLINE(1496)		this->set_borderQuality(Quality);
HXLINE(1497)		if (hx::IsEq( this->borderStyle,::flixel::text::FlxTextBorderStyle_obj::SHADOW_dyn() )) {
HXLINE(1499)			this->shadowOffset->set(this->borderSize,this->borderSize);
            		}
HXLINE(1501)		this->pendingTextBitmapChange = true;
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxBitmapText_obj,setBorderStyle,(void))

int FlxBitmapText_obj::get_fieldWidth(){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1506_get_fieldWidth)
HXDLIN(1506)		if (this->autoSize) {
HXDLIN(1506)			return this->get_textWidth();
            		}
            		else {
HXDLIN(1506)			return this->_fieldWidth;
            		}
HXDLIN(1506)		return (int)0;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxBitmapText_obj,get_fieldWidth,return )

int FlxBitmapText_obj::set_fieldWidth(int value){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1513_set_fieldWidth)
HXLINE(1514)		if ((value > (int)1)) {
HXLINE(1514)			value = value;
            		}
            		else {
HXLINE(1514)			value = (int)1;
            		}
HXLINE(1516)		if ((value != this->_fieldWidth)) {
HXLINE(1518)			if ((value <= (int)0)) {
HXLINE(1520)				this->set_autoSize(true);
HXLINE(1521)				this->set_wordWrap(false);
            			}
HXLINE(1524)			this->pendingTextChange = true;
            		}
HXLINE(1527)		return (this->_fieldWidth = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,set_fieldWidth,return )

::String FlxBitmapText_obj::set_alignment(::String value){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1531_set_alignment)
HXLINE(1532)		bool _hx_tmp;
HXDLIN(1532)		if ((this->alignment != value)) {
HXLINE(1532)			_hx_tmp = (this->alignment != HX_("justify",50,df,b5,83));
            		}
            		else {
HXLINE(1532)			_hx_tmp = false;
            		}
HXDLIN(1532)		if (_hx_tmp) {
HXLINE(1534)			this->alignment = value;
HXLINE(1535)			this->pendingTextBitmapChange = true;
            		}
HXLINE(1538)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,set_alignment,return )

bool FlxBitmapText_obj::set_multiLine(bool value){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1542_set_multiLine)
HXLINE(1543)		if ((this->multiLine != value)) {
HXLINE(1545)			this->multiLine = value;
HXLINE(1546)			this->pendingTextChange = true;
            		}
HXLINE(1549)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,set_multiLine,return )

 ::flixel::graphics::frames::FlxBitmapFont FlxBitmapText_obj::set_font( ::flixel::graphics::frames::FlxBitmapFont value){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1553_set_font)
HXLINE(1554)		if (hx::IsNotEq( this->font,value )) {
HXLINE(1556)			this->font = value;
HXLINE(1557)			this->pendingTextChange = true;
            		}
HXLINE(1560)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,set_font,return )

int FlxBitmapText_obj::set_lineSpacing(int value){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1564_set_lineSpacing)
HXLINE(1565)		if ((this->lineSpacing != value)) {
HXLINE(1567)			this->lineSpacing = value;
HXLINE(1568)			this->pendingTextBitmapChange = true;
            		}
HXLINE(1571)		return this->lineSpacing;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,set_lineSpacing,return )

int FlxBitmapText_obj::set_letterSpacing(int value){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1575_set_letterSpacing)
HXLINE(1576)		if ((value != this->letterSpacing)) {
HXLINE(1578)			this->letterSpacing = value;
HXLINE(1579)			this->pendingTextChange = true;
            		}
HXLINE(1582)		return this->letterSpacing;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,set_letterSpacing,return )

bool FlxBitmapText_obj::set_autoUpperCase(bool value){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1586_set_autoUpperCase)
HXLINE(1587)		if ((this->autoUpperCase != value)) {
HXLINE(1589)			this->autoUpperCase = value;
HXLINE(1590)			this->pendingTextChange = true;
            		}
HXLINE(1593)		return this->autoUpperCase;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,set_autoUpperCase,return )

bool FlxBitmapText_obj::set_wordWrap(bool value){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1597_set_wordWrap)
HXLINE(1598)		if ((this->wordWrap != value)) {
HXLINE(1600)			this->wordWrap = value;
HXLINE(1601)			this->pendingTextChange = true;
            		}
HXLINE(1604)		return this->wordWrap;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,set_wordWrap,return )

bool FlxBitmapText_obj::set_wrapByWord(bool value){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1608_set_wrapByWord)
HXLINE(1609)		if ((this->wrapByWord != value)) {
HXLINE(1611)			this->wrapByWord = value;
HXLINE(1612)			this->pendingTextChange = true;
            		}
HXLINE(1615)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,set_wrapByWord,return )

bool FlxBitmapText_obj::set_autoSize(bool value){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1619_set_autoSize)
HXLINE(1620)		if ((this->autoSize != value)) {
HXLINE(1622)			this->autoSize = value;
HXLINE(1623)			this->pendingTextChange = true;
            		}
HXLINE(1626)		return this->autoSize;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,set_autoSize,return )

int FlxBitmapText_obj::set_padding(int value){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1630_set_padding)
HXLINE(1631)		if ((value != this->padding)) {
HXLINE(1633)			this->padding = value;
HXLINE(1634)			this->pendingTextChange = true;
            		}
HXLINE(1637)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,set_padding,return )

int FlxBitmapText_obj::set_numSpacesInTab(int value){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1641_set_numSpacesInTab)
HXLINE(1642)		bool _hx_tmp;
HXDLIN(1642)		if ((this->numSpacesInTab != value)) {
HXLINE(1642)			_hx_tmp = (value > (int)0);
            		}
            		else {
HXLINE(1642)			_hx_tmp = false;
            		}
HXDLIN(1642)		if (_hx_tmp) {
HXLINE(1644)			this->numSpacesInTab = value;
HXLINE(1645)			this->pendingTextChange = true;
            		}
HXLINE(1648)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,set_numSpacesInTab,return )

bool FlxBitmapText_obj::set_background(bool value){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1652_set_background)
HXLINE(1653)		if ((this->background != value)) {
HXLINE(1655)			this->background = value;
HXLINE(1656)			if (::flixel::FlxG_obj::renderBlit) {
HXLINE(1658)				this->pendingPixelsChange = true;
            			}
            		}
HXLINE(1662)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,set_background,return )

int FlxBitmapText_obj::set_backgroundColor(int value){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1666_set_backgroundColor)
HXLINE(1667)		if ((this->backgroundColor != value)) {
HXLINE(1669)			this->backgroundColor = value;
HXLINE(1670)			if (::flixel::FlxG_obj::renderBlit) {
HXLINE(1672)				this->pendingPixelsChange = true;
            			}
            		}
HXLINE(1676)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,set_backgroundColor,return )

 ::flixel::text::FlxTextBorderStyle FlxBitmapText_obj::set_borderStyle( ::flixel::text::FlxTextBorderStyle style){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1680_set_borderStyle)
HXLINE(1681)		if (hx::IsNotEq( style,this->borderStyle )) {
HXLINE(1683)			this->borderStyle = style;
HXLINE(1684)			this->pendingTextBitmapChange = true;
            		}
HXLINE(1687)		return this->borderStyle;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,set_borderStyle,return )

int FlxBitmapText_obj::set_borderColor(int value){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1691_set_borderColor)
HXLINE(1692)		if ((this->borderColor != value)) {
HXLINE(1694)			this->borderColor = value;
HXLINE(1695)			if (::flixel::FlxG_obj::renderBlit) {
HXLINE(1697)				this->pendingPixelsChange = true;
            			}
            		}
HXLINE(1701)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,set_borderColor,return )

Float FlxBitmapText_obj::set_borderSize(Float value){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1705_set_borderSize)
HXLINE(1706)		if ((value != this->borderSize)) {
HXLINE(1708)			this->borderSize = value;
HXLINE(1710)			if (hx::IsNotEq( this->borderStyle,::flixel::text::FlxTextBorderStyle_obj::NONE_dyn() )) {
HXLINE(1712)				this->pendingTextBitmapChange = true;
            			}
            		}
HXLINE(1716)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,set_borderSize,return )

Float FlxBitmapText_obj::set_borderQuality(Float value){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1720_set_borderQuality)
HXLINE(1721)		value = ::Math_obj::min((int)1,::Math_obj::max((int)0,value));
HXLINE(1723)		if ((value != this->borderQuality)) {
HXLINE(1725)			this->borderQuality = value;
HXLINE(1727)			if (hx::IsNotEq( this->borderStyle,::flixel::text::FlxTextBorderStyle_obj::NONE_dyn() )) {
HXLINE(1729)				this->pendingTextBitmapChange = true;
            			}
            		}
HXLINE(1733)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapText_obj,set_borderQuality,return )

int FlxBitmapText_obj::get_numLines(){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1738_get_numLines)
HXDLIN(1738)		return this->_lines->length;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxBitmapText_obj,get_numLines,return )

int FlxBitmapText_obj::get_textWidth(){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1747_get_textWidth)
HXLINE(1748)		int max = (int)0;
HXLINE(1749)		int numLines = this->_lines->length;
HXLINE(1750)		int lineWidth;
HXLINE(1751)		this->_linesWidth = ::Array_obj< int >::__new(0);
HXLINE(1753)		{
HXLINE(1753)			int _g1 = (int)0;
HXDLIN(1753)			int _g = numLines;
HXDLIN(1753)			while((_g1 < _g)){
HXLINE(1753)				_g1 = (_g1 + (int)1);
HXDLIN(1753)				int i = (_g1 - (int)1);
HXLINE(1755)				lineWidth = this->getLineWidth(i);
HXLINE(1756)				this->_linesWidth[i] = lineWidth;
HXLINE(1757)				if ((max > lineWidth)) {
HXLINE(1757)					max = max;
            				}
            				else {
HXLINE(1757)					max = lineWidth;
            				}
            			}
            		}
HXLINE(1760)		return max;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxBitmapText_obj,get_textWidth,return )

int FlxBitmapText_obj::get_textHeight(){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1765_get_textHeight)
HXDLIN(1765)		int _hx_tmp = this->get_lineHeight();
HXDLIN(1765)		return (((_hx_tmp + this->lineSpacing) * this->_lines->length) - this->lineSpacing);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxBitmapText_obj,get_textHeight,return )

int FlxBitmapText_obj::get_lineHeight(){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1770_get_lineHeight)
HXDLIN(1770)		return this->font->lineHeight;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxBitmapText_obj,get_lineHeight,return )

Float FlxBitmapText_obj::get_width(){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1774_get_width)
HXLINE(1775)		{
HXLINE(1775)			bool useTiles = true;
HXDLIN(1775)			if (::flixel::FlxG_obj::renderBlit) {
HXLINE(1775)				useTiles = false;
            			}
HXDLIN(1775)			if (this->pendingTextChange) {
HXLINE(1775)				this->updateText();
HXDLIN(1775)				this->pendingTextBitmapChange = true;
            			}
HXDLIN(1775)			if (this->pendingTextBitmapChange) {
HXLINE(1775)				this->updateTextBitmap(useTiles);
HXDLIN(1775)				this->pendingPixelsChange = true;
            			}
HXDLIN(1775)			if (this->pendingPixelsChange) {
HXLINE(1775)				this->updatePixels(useTiles);
            			}
            		}
HXLINE(1776)		return this->super::get_width();
            	}


Float FlxBitmapText_obj::get_height(){
            	HX_STACKFRAME(&_hx_pos_9e790623cbe1e5f4_1780_get_height)
HXLINE(1781)		{
HXLINE(1781)			bool useTiles = true;
HXDLIN(1781)			if (::flixel::FlxG_obj::renderBlit) {
HXLINE(1781)				useTiles = false;
            			}
HXDLIN(1781)			if (this->pendingTextChange) {
HXLINE(1781)				this->updateText();
HXDLIN(1781)				this->pendingTextBitmapChange = true;
            			}
HXDLIN(1781)			if (this->pendingTextBitmapChange) {
HXLINE(1781)				this->updateTextBitmap(useTiles);
HXDLIN(1781)				this->pendingPixelsChange = true;
            			}
HXDLIN(1781)			if (this->pendingPixelsChange) {
HXLINE(1781)				this->updatePixels(useTiles);
            			}
            		}
HXLINE(1782)		return this->super::get_height();
            	}



hx::ObjectPtr< FlxBitmapText_obj > FlxBitmapText_obj::__new( ::flixel::graphics::frames::FlxBitmapFont font) {
	hx::ObjectPtr< FlxBitmapText_obj > __this = new FlxBitmapText_obj();
	__this->__construct(font);
	return __this;
}

hx::ObjectPtr< FlxBitmapText_obj > FlxBitmapText_obj::__alloc(hx::Ctx *_hx_ctx, ::flixel::graphics::frames::FlxBitmapFont font) {
	FlxBitmapText_obj *__this = (FlxBitmapText_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(FlxBitmapText_obj), true, "flixel.text.FlxBitmapText"));
	*(void **)__this = FlxBitmapText_obj::_hx_vtable;
	__this->__construct(font);
	return __this;
}

FlxBitmapText_obj::FlxBitmapText_obj()
{
}

void FlxBitmapText_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(FlxBitmapText);
	HX_MARK_MEMBER_NAME(font,"font");
	HX_MARK_MEMBER_NAME(text,"text");
	HX_MARK_MEMBER_NAME(_colorParams,"_colorParams");
	HX_MARK_MEMBER_NAME(_lines,"_lines");
	HX_MARK_MEMBER_NAME(_linesWidth,"_linesWidth");
	HX_MARK_MEMBER_NAME(alignment,"alignment");
	HX_MARK_MEMBER_NAME(lineSpacing,"lineSpacing");
	HX_MARK_MEMBER_NAME(letterSpacing,"letterSpacing");
	HX_MARK_MEMBER_NAME(autoUpperCase,"autoUpperCase");
	HX_MARK_MEMBER_NAME(wordWrap,"wordWrap");
	HX_MARK_MEMBER_NAME(wrapByWord,"wrapByWord");
	HX_MARK_MEMBER_NAME(autoSize,"autoSize");
	HX_MARK_MEMBER_NAME(padding,"padding");
	HX_MARK_MEMBER_NAME(textWidth,"textWidth");
	HX_MARK_MEMBER_NAME(textHeight,"textHeight");
	HX_MARK_MEMBER_NAME(lineHeight,"lineHeight");
	HX_MARK_MEMBER_NAME(numSpacesInTab,"numSpacesInTab");
	HX_MARK_MEMBER_NAME(textColor,"textColor");
	HX_MARK_MEMBER_NAME(useTextColor,"useTextColor");
	HX_MARK_MEMBER_NAME(borderStyle,"borderStyle");
	HX_MARK_MEMBER_NAME(borderColor,"borderColor");
	HX_MARK_MEMBER_NAME(borderSize,"borderSize");
	HX_MARK_MEMBER_NAME(borderQuality,"borderQuality");
	HX_MARK_MEMBER_NAME(shadowOffset,"shadowOffset");
	HX_MARK_MEMBER_NAME(background,"background");
	HX_MARK_MEMBER_NAME(backgroundColor,"backgroundColor");
	HX_MARK_MEMBER_NAME(multiLine,"multiLine");
	HX_MARK_MEMBER_NAME(numLines,"numLines");
	HX_MARK_MEMBER_NAME(_fieldWidth,"_fieldWidth");
	HX_MARK_MEMBER_NAME(pendingTextChange,"pendingTextChange");
	HX_MARK_MEMBER_NAME(pendingTextBitmapChange,"pendingTextBitmapChange");
	HX_MARK_MEMBER_NAME(pendingPixelsChange,"pendingPixelsChange");
	HX_MARK_MEMBER_NAME(textData,"textData");
	HX_MARK_MEMBER_NAME(textDrawData,"textDrawData");
	HX_MARK_MEMBER_NAME(borderDrawData,"borderDrawData");
	HX_MARK_MEMBER_NAME(textBitmap,"textBitmap");
	 ::flixel::FlxSprite_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void FlxBitmapText_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(font,"font");
	HX_VISIT_MEMBER_NAME(text,"text");
	HX_VISIT_MEMBER_NAME(_colorParams,"_colorParams");
	HX_VISIT_MEMBER_NAME(_lines,"_lines");
	HX_VISIT_MEMBER_NAME(_linesWidth,"_linesWidth");
	HX_VISIT_MEMBER_NAME(alignment,"alignment");
	HX_VISIT_MEMBER_NAME(lineSpacing,"lineSpacing");
	HX_VISIT_MEMBER_NAME(letterSpacing,"letterSpacing");
	HX_VISIT_MEMBER_NAME(autoUpperCase,"autoUpperCase");
	HX_VISIT_MEMBER_NAME(wordWrap,"wordWrap");
	HX_VISIT_MEMBER_NAME(wrapByWord,"wrapByWord");
	HX_VISIT_MEMBER_NAME(autoSize,"autoSize");
	HX_VISIT_MEMBER_NAME(padding,"padding");
	HX_VISIT_MEMBER_NAME(textWidth,"textWidth");
	HX_VISIT_MEMBER_NAME(textHeight,"textHeight");
	HX_VISIT_MEMBER_NAME(lineHeight,"lineHeight");
	HX_VISIT_MEMBER_NAME(numSpacesInTab,"numSpacesInTab");
	HX_VISIT_MEMBER_NAME(textColor,"textColor");
	HX_VISIT_MEMBER_NAME(useTextColor,"useTextColor");
	HX_VISIT_MEMBER_NAME(borderStyle,"borderStyle");
	HX_VISIT_MEMBER_NAME(borderColor,"borderColor");
	HX_VISIT_MEMBER_NAME(borderSize,"borderSize");
	HX_VISIT_MEMBER_NAME(borderQuality,"borderQuality");
	HX_VISIT_MEMBER_NAME(shadowOffset,"shadowOffset");
	HX_VISIT_MEMBER_NAME(background,"background");
	HX_VISIT_MEMBER_NAME(backgroundColor,"backgroundColor");
	HX_VISIT_MEMBER_NAME(multiLine,"multiLine");
	HX_VISIT_MEMBER_NAME(numLines,"numLines");
	HX_VISIT_MEMBER_NAME(_fieldWidth,"_fieldWidth");
	HX_VISIT_MEMBER_NAME(pendingTextChange,"pendingTextChange");
	HX_VISIT_MEMBER_NAME(pendingTextBitmapChange,"pendingTextBitmapChange");
	HX_VISIT_MEMBER_NAME(pendingPixelsChange,"pendingPixelsChange");
	HX_VISIT_MEMBER_NAME(textData,"textData");
	HX_VISIT_MEMBER_NAME(textDrawData,"textDrawData");
	HX_VISIT_MEMBER_NAME(borderDrawData,"borderDrawData");
	HX_VISIT_MEMBER_NAME(textBitmap,"textBitmap");
	 ::flixel::FlxSprite_obj::__Visit(HX_VISIT_ARG);
}

hx::Val FlxBitmapText_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"font") ) { return hx::Val( font ); }
		if (HX_FIELD_EQ(inName,"text") ) { return hx::Val( text ); }
		if (HX_FIELD_EQ(inName,"draw") ) { return hx::Val( draw_dyn() ); }
		if (HX_FIELD_EQ(inName,"wrap") ) { return hx::Val( wrap_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"_lines") ) { return hx::Val( _lines ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"padding") ) { return hx::Val( padding ); }
		if (HX_FIELD_EQ(inName,"destroy") ) { return hx::Val( destroy_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"wordWrap") ) { return hx::Val( wordWrap ); }
		if (HX_FIELD_EQ(inName,"autoSize") ) { return hx::Val( autoSize ); }
		if (HX_FIELD_EQ(inName,"numLines") ) { return hx::Val( inCallProp == hx::paccAlways ? get_numLines() : numLines ); }
		if (HX_FIELD_EQ(inName,"textData") ) { return hx::Val( textData ); }
		if (HX_FIELD_EQ(inName,"set_text") ) { return hx::Val( set_text_dyn() ); }
		if (HX_FIELD_EQ(inName,"cutLines") ) { return hx::Val( cutLines_dyn() ); }
		if (HX_FIELD_EQ(inName,"drawLine") ) { return hx::Val( drawLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"blitLine") ) { return hx::Val( blitLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"tileLine") ) { return hx::Val( tileLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"drawText") ) { return hx::Val( drawText_dyn() ); }
		if (HX_FIELD_EQ(inName,"blitText") ) { return hx::Val( blitText_dyn() ); }
		if (HX_FIELD_EQ(inName,"tileText") ) { return hx::Val( tileText_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_font") ) { return hx::Val( set_font_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"alignment") ) { return hx::Val( alignment ); }
		if (HX_FIELD_EQ(inName,"textWidth") ) { return hx::Val( inCallProp == hx::paccAlways ? get_textWidth() : textWidth ); }
		if (HX_FIELD_EQ(inName,"textColor") ) { return hx::Val( textColor ); }
		if (HX_FIELD_EQ(inName,"multiLine") ) { return hx::Val( multiLine ); }
		if (HX_FIELD_EQ(inName,"drawFrame") ) { return hx::Val( drawFrame_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_color") ) { return hx::Val( set_color_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_alpha") ) { return hx::Val( set_alpha_dyn() ); }
		if (HX_FIELD_EQ(inName,"calcFrame") ) { return hx::Val( calcFrame_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_width") ) { return hx::Val( get_width_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"wrapByWord") ) { return hx::Val( wrapByWord ); }
		if (HX_FIELD_EQ(inName,"textHeight") ) { return hx::Val( inCallProp == hx::paccAlways ? get_textHeight() : textHeight ); }
		if (HX_FIELD_EQ(inName,"lineHeight") ) { return hx::Val( inCallProp == hx::paccAlways ? get_lineHeight() : lineHeight ); }
		if (HX_FIELD_EQ(inName,"borderSize") ) { return hx::Val( borderSize ); }
		if (HX_FIELD_EQ(inName,"background") ) { return hx::Val( background ); }
		if (HX_FIELD_EQ(inName,"fieldWidth") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_fieldWidth() ); }
		if (HX_FIELD_EQ(inName,"textBitmap") ) { return hx::Val( textBitmap ); }
		if (HX_FIELD_EQ(inName,"updateText") ) { return hx::Val( updateText_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_height") ) { return hx::Val( get_height_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_linesWidth") ) { return hx::Val( _linesWidth ); }
		if (HX_FIELD_EQ(inName,"lineSpacing") ) { return hx::Val( lineSpacing ); }
		if (HX_FIELD_EQ(inName,"borderStyle") ) { return hx::Val( borderStyle ); }
		if (HX_FIELD_EQ(inName,"borderColor") ) { return hx::Val( borderColor ); }
		if (HX_FIELD_EQ(inName,"_fieldWidth") ) { return hx::Val( _fieldWidth ); }
		if (HX_FIELD_EQ(inName,"set_padding") ) { return hx::Val( set_padding_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"_colorParams") ) { return hx::Val( _colorParams ); }
		if (HX_FIELD_EQ(inName,"useTextColor") ) { return hx::Val( useTextColor ); }
		if (HX_FIELD_EQ(inName,"shadowOffset") ) { return hx::Val( shadowOffset ); }
		if (HX_FIELD_EQ(inName,"textDrawData") ) { return hx::Val( textDrawData ); }
		if (HX_FIELD_EQ(inName,"getLineWidth") ) { return hx::Val( getLineWidth_dyn() ); }
		if (HX_FIELD_EQ(inName,"updatePixels") ) { return hx::Val( updatePixels_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_wordWrap") ) { return hx::Val( set_wordWrap_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_autoSize") ) { return hx::Val( set_autoSize_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_numLines") ) { return hx::Val( get_numLines_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"letterSpacing") ) { return hx::Val( letterSpacing ); }
		if (HX_FIELD_EQ(inName,"autoUpperCase") ) { return hx::Val( autoUpperCase ); }
		if (HX_FIELD_EQ(inName,"borderQuality") ) { return hx::Val( borderQuality ); }
		if (HX_FIELD_EQ(inName,"set_textColor") ) { return hx::Val( set_textColor_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_alignment") ) { return hx::Val( set_alignment_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_multiLine") ) { return hx::Val( set_multiLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_textWidth") ) { return hx::Val( get_textWidth_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"numSpacesInTab") ) { return hx::Val( numSpacesInTab ); }
		if (HX_FIELD_EQ(inName,"borderDrawData") ) { return hx::Val( borderDrawData ); }
		if (HX_FIELD_EQ(inName,"getStringWidth") ) { return hx::Val( getStringWidth_dyn() ); }
		if (HX_FIELD_EQ(inName,"wrapLineByWord") ) { return hx::Val( wrapLineByWord_dyn() ); }
		if (HX_FIELD_EQ(inName,"setBorderStyle") ) { return hx::Val( setBorderStyle_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_fieldWidth") ) { return hx::Val( get_fieldWidth_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_fieldWidth") ) { return hx::Val( set_fieldWidth_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_wrapByWord") ) { return hx::Val( set_wrapByWord_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_background") ) { return hx::Val( set_background_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_borderSize") ) { return hx::Val( set_borderSize_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_textHeight") ) { return hx::Val( get_textHeight_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_lineHeight") ) { return hx::Val( get_lineHeight_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"backgroundColor") ) { return hx::Val( backgroundColor ); }
		if (HX_FIELD_EQ(inName,"computeTextSize") ) { return hx::Val( computeTextSize_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_lineSpacing") ) { return hx::Val( set_lineSpacing_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_borderStyle") ) { return hx::Val( set_borderStyle_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_borderColor") ) { return hx::Val( set_borderColor_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"set_useTextColor") ) { return hx::Val( set_useTextColor_dyn() ); }
		if (HX_FIELD_EQ(inName,"updateTextBitmap") ) { return hx::Val( updateTextBitmap_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"pendingTextChange") ) { return hx::Val( pendingTextChange ); }
		if (HX_FIELD_EQ(inName,"set_letterSpacing") ) { return hx::Val( set_letterSpacing_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_autoUpperCase") ) { return hx::Val( set_autoUpperCase_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_borderQuality") ) { return hx::Val( set_borderQuality_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"splitLineIntoWords") ) { return hx::Val( splitLineIntoWords_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_numSpacesInTab") ) { return hx::Val( set_numSpacesInTab_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"pendingPixelsChange") ) { return hx::Val( pendingPixelsChange ); }
		if (HX_FIELD_EQ(inName,"checkPendingChanges") ) { return hx::Val( checkPendingChanges_dyn() ); }
		if (HX_FIELD_EQ(inName,"wrapLineByCharacter") ) { return hx::Val( wrapLineByCharacter_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_backgroundColor") ) { return hx::Val( set_backgroundColor_dyn() ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"pendingTextBitmapChange") ) { return hx::Val( pendingTextBitmapChange ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val FlxBitmapText_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"font") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_font(inValue.Cast<  ::flixel::graphics::frames::FlxBitmapFont >()) );font=inValue.Cast<  ::flixel::graphics::frames::FlxBitmapFont >(); return inValue; }
		if (HX_FIELD_EQ(inName,"text") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_text(inValue.Cast< ::String >()) );text=inValue.Cast< ::String >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"_lines") ) { _lines=inValue.Cast< ::Array< ::String > >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"padding") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_padding(inValue.Cast< int >()) );padding=inValue.Cast< int >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"wordWrap") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_wordWrap(inValue.Cast< bool >()) );wordWrap=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"autoSize") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_autoSize(inValue.Cast< bool >()) );autoSize=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"numLines") ) { numLines=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"textData") ) { textData=inValue.Cast< ::Array< Float > >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"alignment") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_alignment(inValue.Cast< ::String >()) );alignment=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"textWidth") ) { textWidth=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"textColor") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_textColor(inValue.Cast< int >()) );textColor=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"multiLine") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_multiLine(inValue.Cast< bool >()) );multiLine=inValue.Cast< bool >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"wrapByWord") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_wrapByWord(inValue.Cast< bool >()) );wrapByWord=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"textHeight") ) { textHeight=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lineHeight") ) { lineHeight=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"borderSize") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_borderSize(inValue.Cast< Float >()) );borderSize=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"background") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_background(inValue.Cast< bool >()) );background=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"fieldWidth") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_fieldWidth(inValue.Cast< int >()) ); }
		if (HX_FIELD_EQ(inName,"textBitmap") ) { textBitmap=inValue.Cast<  ::openfl::_legacy::display::BitmapData >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_linesWidth") ) { _linesWidth=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lineSpacing") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_lineSpacing(inValue.Cast< int >()) );lineSpacing=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"borderStyle") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_borderStyle(inValue.Cast<  ::flixel::text::FlxTextBorderStyle >()) );borderStyle=inValue.Cast<  ::flixel::text::FlxTextBorderStyle >(); return inValue; }
		if (HX_FIELD_EQ(inName,"borderColor") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_borderColor(inValue.Cast< int >()) );borderColor=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_fieldWidth") ) { _fieldWidth=inValue.Cast< int >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"_colorParams") ) { _colorParams=inValue.Cast<  ::openfl::_legacy::geom::ColorTransform >(); return inValue; }
		if (HX_FIELD_EQ(inName,"useTextColor") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_useTextColor(inValue.Cast< bool >()) );useTextColor=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"shadowOffset") ) { shadowOffset=inValue.Cast<  ::flixel::math::FlxPoint >(); return inValue; }
		if (HX_FIELD_EQ(inName,"textDrawData") ) { textDrawData=inValue.Cast< ::Array< Float > >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"letterSpacing") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_letterSpacing(inValue.Cast< int >()) );letterSpacing=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"autoUpperCase") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_autoUpperCase(inValue.Cast< bool >()) );autoUpperCase=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"borderQuality") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_borderQuality(inValue.Cast< Float >()) );borderQuality=inValue.Cast< Float >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"numSpacesInTab") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_numSpacesInTab(inValue.Cast< int >()) );numSpacesInTab=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"borderDrawData") ) { borderDrawData=inValue.Cast< ::Array< Float > >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"backgroundColor") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_backgroundColor(inValue.Cast< int >()) );backgroundColor=inValue.Cast< int >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"pendingTextChange") ) { pendingTextChange=inValue.Cast< bool >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"pendingPixelsChange") ) { pendingPixelsChange=inValue.Cast< bool >(); return inValue; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"pendingTextBitmapChange") ) { pendingTextBitmapChange=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void FlxBitmapText_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("font","\xcf","\x5d","\xc0","\x43"));
	outFields->push(HX_HCSTRING("text","\xad","\xcc","\xf9","\x4c"));
	outFields->push(HX_HCSTRING("_colorParams","\x0a","\x3b","\xad","\x0d"));
	outFields->push(HX_HCSTRING("_lines","\x40","\x25","\xe9","\x70"));
	outFields->push(HX_HCSTRING("_linesWidth","\xa6","\xf8","\x37","\xcb"));
	outFields->push(HX_HCSTRING("alignment","\xe3","\xe2","\x3d","\xea"));
	outFields->push(HX_HCSTRING("lineSpacing","\xef","\xe9","\x0e","\xd0"));
	outFields->push(HX_HCSTRING("letterSpacing","\x3d","\xb7","\x03","\xf5"));
	outFields->push(HX_HCSTRING("autoUpperCase","\xc3","\xd7","\x69","\xb3"));
	outFields->push(HX_HCSTRING("wordWrap","\xb4","\x14","\xdb","\x00"));
	outFields->push(HX_HCSTRING("wrapByWord","\xab","\xdc","\x7f","\x78"));
	outFields->push(HX_HCSTRING("autoSize","\xd0","\x8f","\x79","\x2f"));
	outFields->push(HX_HCSTRING("padding","\xd1","\x59","\x7d","\xd0"));
	outFields->push(HX_HCSTRING("textWidth","\x19","\x46","\x50","\x63"));
	outFields->push(HX_HCSTRING("textHeight","\x74","\x88","\x3c","\x39"));
	outFields->push(HX_HCSTRING("lineHeight","\xfb","\x02","\xf4","\xd6"));
	outFields->push(HX_HCSTRING("numSpacesInTab","\x9d","\x3a","\xd9","\x2e"));
	outFields->push(HX_HCSTRING("textColor","\x76","\x01","\x4a","\xe3"));
	outFields->push(HX_HCSTRING("useTextColor","\x2f","\x74","\xe5","\x52"));
	outFields->push(HX_HCSTRING("borderStyle","\xa5","\x70","\x96","\x10"));
	outFields->push(HX_HCSTRING("borderColor","\xd7","\x3c","\xd5","\xd6"));
	outFields->push(HX_HCSTRING("borderSize","\xcd","\xff","\xed","\x06"));
	outFields->push(HX_HCSTRING("borderQuality","\x33","\x95","\x25","\x79"));
	outFields->push(HX_HCSTRING("shadowOffset","\x93","\xfb","\x0b","\xdc"));
	outFields->push(HX_HCSTRING("background","\xee","\x93","\x1d","\x26"));
	outFields->push(HX_HCSTRING("backgroundColor","\x95","\x4e","\x47","\x0d"));
	outFields->push(HX_HCSTRING("multiLine","\x0d","\xff","\xea","\x88"));
	outFields->push(HX_HCSTRING("numLines","\xd9","\xf1","\x11","\x32"));
	outFields->push(HX_HCSTRING("fieldWidth","\xec","\x2e","\xe5","\x97"));
	outFields->push(HX_HCSTRING("_fieldWidth","\x0b","\xfc","\x6e","\x6a"));
	outFields->push(HX_HCSTRING("pendingTextChange","\x34","\x21","\x45","\x8b"));
	outFields->push(HX_HCSTRING("pendingTextBitmapChange","\x83","\xed","\xa8","\x93"));
	outFields->push(HX_HCSTRING("pendingPixelsChange","\x74","\x9f","\x81","\xdb"));
	outFields->push(HX_HCSTRING("textData","\x77","\xa9","\x5e","\x45"));
	outFields->push(HX_HCSTRING("textDrawData","\x1b","\x7e","\x48","\x8b"));
	outFields->push(HX_HCSTRING("borderDrawData","\x5a","\xd5","\x51","\x60"));
	outFields->push(HX_HCSTRING("textBitmap","\x7c","\x90","\xfc","\x27"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo FlxBitmapText_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::flixel::graphics::frames::FlxBitmapFont*/ ,(int)offsetof(FlxBitmapText_obj,font),HX_HCSTRING("font","\xcf","\x5d","\xc0","\x43")},
	{hx::fsString,(int)offsetof(FlxBitmapText_obj,text),HX_HCSTRING("text","\xad","\xcc","\xf9","\x4c")},
	{hx::fsObject /*::openfl::_legacy::geom::ColorTransform*/ ,(int)offsetof(FlxBitmapText_obj,_colorParams),HX_HCSTRING("_colorParams","\x0a","\x3b","\xad","\x0d")},
	{hx::fsObject /*Array< ::String >*/ ,(int)offsetof(FlxBitmapText_obj,_lines),HX_HCSTRING("_lines","\x40","\x25","\xe9","\x70")},
	{hx::fsObject /*Array< int >*/ ,(int)offsetof(FlxBitmapText_obj,_linesWidth),HX_HCSTRING("_linesWidth","\xa6","\xf8","\x37","\xcb")},
	{hx::fsString,(int)offsetof(FlxBitmapText_obj,alignment),HX_HCSTRING("alignment","\xe3","\xe2","\x3d","\xea")},
	{hx::fsInt,(int)offsetof(FlxBitmapText_obj,lineSpacing),HX_HCSTRING("lineSpacing","\xef","\xe9","\x0e","\xd0")},
	{hx::fsInt,(int)offsetof(FlxBitmapText_obj,letterSpacing),HX_HCSTRING("letterSpacing","\x3d","\xb7","\x03","\xf5")},
	{hx::fsBool,(int)offsetof(FlxBitmapText_obj,autoUpperCase),HX_HCSTRING("autoUpperCase","\xc3","\xd7","\x69","\xb3")},
	{hx::fsBool,(int)offsetof(FlxBitmapText_obj,wordWrap),HX_HCSTRING("wordWrap","\xb4","\x14","\xdb","\x00")},
	{hx::fsBool,(int)offsetof(FlxBitmapText_obj,wrapByWord),HX_HCSTRING("wrapByWord","\xab","\xdc","\x7f","\x78")},
	{hx::fsBool,(int)offsetof(FlxBitmapText_obj,autoSize),HX_HCSTRING("autoSize","\xd0","\x8f","\x79","\x2f")},
	{hx::fsInt,(int)offsetof(FlxBitmapText_obj,padding),HX_HCSTRING("padding","\xd1","\x59","\x7d","\xd0")},
	{hx::fsInt,(int)offsetof(FlxBitmapText_obj,textWidth),HX_HCSTRING("textWidth","\x19","\x46","\x50","\x63")},
	{hx::fsInt,(int)offsetof(FlxBitmapText_obj,textHeight),HX_HCSTRING("textHeight","\x74","\x88","\x3c","\x39")},
	{hx::fsInt,(int)offsetof(FlxBitmapText_obj,lineHeight),HX_HCSTRING("lineHeight","\xfb","\x02","\xf4","\xd6")},
	{hx::fsInt,(int)offsetof(FlxBitmapText_obj,numSpacesInTab),HX_HCSTRING("numSpacesInTab","\x9d","\x3a","\xd9","\x2e")},
	{hx::fsInt,(int)offsetof(FlxBitmapText_obj,textColor),HX_HCSTRING("textColor","\x76","\x01","\x4a","\xe3")},
	{hx::fsBool,(int)offsetof(FlxBitmapText_obj,useTextColor),HX_HCSTRING("useTextColor","\x2f","\x74","\xe5","\x52")},
	{hx::fsObject /*::flixel::text::FlxTextBorderStyle*/ ,(int)offsetof(FlxBitmapText_obj,borderStyle),HX_HCSTRING("borderStyle","\xa5","\x70","\x96","\x10")},
	{hx::fsInt,(int)offsetof(FlxBitmapText_obj,borderColor),HX_HCSTRING("borderColor","\xd7","\x3c","\xd5","\xd6")},
	{hx::fsFloat,(int)offsetof(FlxBitmapText_obj,borderSize),HX_HCSTRING("borderSize","\xcd","\xff","\xed","\x06")},
	{hx::fsFloat,(int)offsetof(FlxBitmapText_obj,borderQuality),HX_HCSTRING("borderQuality","\x33","\x95","\x25","\x79")},
	{hx::fsObject /*::flixel::math::FlxPoint*/ ,(int)offsetof(FlxBitmapText_obj,shadowOffset),HX_HCSTRING("shadowOffset","\x93","\xfb","\x0b","\xdc")},
	{hx::fsBool,(int)offsetof(FlxBitmapText_obj,background),HX_HCSTRING("background","\xee","\x93","\x1d","\x26")},
	{hx::fsInt,(int)offsetof(FlxBitmapText_obj,backgroundColor),HX_HCSTRING("backgroundColor","\x95","\x4e","\x47","\x0d")},
	{hx::fsBool,(int)offsetof(FlxBitmapText_obj,multiLine),HX_HCSTRING("multiLine","\x0d","\xff","\xea","\x88")},
	{hx::fsInt,(int)offsetof(FlxBitmapText_obj,numLines),HX_HCSTRING("numLines","\xd9","\xf1","\x11","\x32")},
	{hx::fsInt,(int)offsetof(FlxBitmapText_obj,_fieldWidth),HX_HCSTRING("_fieldWidth","\x0b","\xfc","\x6e","\x6a")},
	{hx::fsBool,(int)offsetof(FlxBitmapText_obj,pendingTextChange),HX_HCSTRING("pendingTextChange","\x34","\x21","\x45","\x8b")},
	{hx::fsBool,(int)offsetof(FlxBitmapText_obj,pendingTextBitmapChange),HX_HCSTRING("pendingTextBitmapChange","\x83","\xed","\xa8","\x93")},
	{hx::fsBool,(int)offsetof(FlxBitmapText_obj,pendingPixelsChange),HX_HCSTRING("pendingPixelsChange","\x74","\x9f","\x81","\xdb")},
	{hx::fsObject /*Array< Float >*/ ,(int)offsetof(FlxBitmapText_obj,textData),HX_HCSTRING("textData","\x77","\xa9","\x5e","\x45")},
	{hx::fsObject /*Array< Float >*/ ,(int)offsetof(FlxBitmapText_obj,textDrawData),HX_HCSTRING("textDrawData","\x1b","\x7e","\x48","\x8b")},
	{hx::fsObject /*Array< Float >*/ ,(int)offsetof(FlxBitmapText_obj,borderDrawData),HX_HCSTRING("borderDrawData","\x5a","\xd5","\x51","\x60")},
	{hx::fsObject /*::openfl::_legacy::display::BitmapData*/ ,(int)offsetof(FlxBitmapText_obj,textBitmap),HX_HCSTRING("textBitmap","\x7c","\x90","\xfc","\x27")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *FlxBitmapText_obj_sStaticStorageInfo = 0;
#endif

static ::String FlxBitmapText_obj_sMemberFields[] = {
	HX_HCSTRING("font","\xcf","\x5d","\xc0","\x43"),
	HX_HCSTRING("text","\xad","\xcc","\xf9","\x4c"),
	HX_HCSTRING("_colorParams","\x0a","\x3b","\xad","\x0d"),
	HX_HCSTRING("_lines","\x40","\x25","\xe9","\x70"),
	HX_HCSTRING("_linesWidth","\xa6","\xf8","\x37","\xcb"),
	HX_HCSTRING("alignment","\xe3","\xe2","\x3d","\xea"),
	HX_HCSTRING("lineSpacing","\xef","\xe9","\x0e","\xd0"),
	HX_HCSTRING("letterSpacing","\x3d","\xb7","\x03","\xf5"),
	HX_HCSTRING("autoUpperCase","\xc3","\xd7","\x69","\xb3"),
	HX_HCSTRING("wordWrap","\xb4","\x14","\xdb","\x00"),
	HX_HCSTRING("wrapByWord","\xab","\xdc","\x7f","\x78"),
	HX_HCSTRING("autoSize","\xd0","\x8f","\x79","\x2f"),
	HX_HCSTRING("padding","\xd1","\x59","\x7d","\xd0"),
	HX_HCSTRING("textWidth","\x19","\x46","\x50","\x63"),
	HX_HCSTRING("textHeight","\x74","\x88","\x3c","\x39"),
	HX_HCSTRING("lineHeight","\xfb","\x02","\xf4","\xd6"),
	HX_HCSTRING("numSpacesInTab","\x9d","\x3a","\xd9","\x2e"),
	HX_HCSTRING("textColor","\x76","\x01","\x4a","\xe3"),
	HX_HCSTRING("useTextColor","\x2f","\x74","\xe5","\x52"),
	HX_HCSTRING("borderStyle","\xa5","\x70","\x96","\x10"),
	HX_HCSTRING("borderColor","\xd7","\x3c","\xd5","\xd6"),
	HX_HCSTRING("borderSize","\xcd","\xff","\xed","\x06"),
	HX_HCSTRING("borderQuality","\x33","\x95","\x25","\x79"),
	HX_HCSTRING("shadowOffset","\x93","\xfb","\x0b","\xdc"),
	HX_HCSTRING("background","\xee","\x93","\x1d","\x26"),
	HX_HCSTRING("backgroundColor","\x95","\x4e","\x47","\x0d"),
	HX_HCSTRING("multiLine","\x0d","\xff","\xea","\x88"),
	HX_HCSTRING("numLines","\xd9","\xf1","\x11","\x32"),
	HX_HCSTRING("_fieldWidth","\x0b","\xfc","\x6e","\x6a"),
	HX_HCSTRING("pendingTextChange","\x34","\x21","\x45","\x8b"),
	HX_HCSTRING("pendingTextBitmapChange","\x83","\xed","\xa8","\x93"),
	HX_HCSTRING("pendingPixelsChange","\x74","\x9f","\x81","\xdb"),
	HX_HCSTRING("textData","\x77","\xa9","\x5e","\x45"),
	HX_HCSTRING("textDrawData","\x1b","\x7e","\x48","\x8b"),
	HX_HCSTRING("borderDrawData","\x5a","\xd5","\x51","\x60"),
	HX_HCSTRING("textBitmap","\x7c","\x90","\xfc","\x27"),
	HX_HCSTRING("destroy","\xfa","\x2c","\x86","\x24"),
	HX_HCSTRING("drawFrame","\x89","\xad","\x8e","\xce"),
	HX_HCSTRING("checkPendingChanges","\x54","\x04","\x94","\x75"),
	HX_HCSTRING("draw","\x04","\x2c","\x70","\x42"),
	HX_HCSTRING("set_color","\xc6","\xb9","\x56","\x71"),
	HX_HCSTRING("set_alpha","\xc1","\xef","\x90","\x48"),
	HX_HCSTRING("set_textColor","\x59","\xb7","\xb3","\xe9"),
	HX_HCSTRING("set_useTextColor","\x2c","\x4e","\xc6","\xad"),
	HX_HCSTRING("calcFrame","\x58","\x93","\x8c","\xf9"),
	HX_HCSTRING("set_text","\xaa","\xe1","\x11","\x7b"),
	HX_HCSTRING("updateText","\x56","\xb7","\xae","\x05"),
	HX_HCSTRING("computeTextSize","\xa5","\xc6","\xcf","\xe6"),
	HX_HCSTRING("getLineWidth","\xfc","\x55","\xb4","\x20"),
	HX_HCSTRING("getStringWidth","\x7f","\xba","\x03","\x5d"),
	HX_HCSTRING("cutLines","\x1d","\x91","\x66","\x89"),
	HX_HCSTRING("wrap","\xca","\x39","\xff","\x4e"),
	HX_HCSTRING("splitLineIntoWords","\xdb","\x44","\xa9","\x26"),
	HX_HCSTRING("wrapLineByWord","\xbf","\xd4","\xc5","\xb8"),
	HX_HCSTRING("wrapLineByCharacter","\x94","\x30","\x3f","\x4a"),
	HX_HCSTRING("updateTextBitmap","\xe5","\x5f","\xe8","\x71"),
	HX_HCSTRING("drawLine","\x18","\xc2","\x1c","\x5c"),
	HX_HCSTRING("blitLine","\xc9","\x3a","\xde","\x68"),
	HX_HCSTRING("tileLine","\x42","\x3e","\xb9","\x81"),
	HX_HCSTRING("updatePixels","\x16","\x96","\x6d","\x8c"),
	HX_HCSTRING("drawText","\xd1","\x76","\x63","\x61"),
	HX_HCSTRING("blitText","\x82","\xef","\x24","\x6e"),
	HX_HCSTRING("tileText","\xfb","\xf2","\xff","\x86"),
	HX_HCSTRING("setBorderStyle","\x23","\xac","\x54","\xb8"),
	HX_HCSTRING("get_fieldWidth","\x35","\xb7","\xda","\x0d"),
	HX_HCSTRING("set_fieldWidth","\xa9","\x9f","\xfa","\x2d"),
	HX_HCSTRING("set_alignment","\xc6","\x98","\xa7","\xf0"),
	HX_HCSTRING("set_multiLine","\xf0","\xb4","\x54","\x8f"),
	HX_HCSTRING("set_font","\xcc","\x72","\xd8","\x71"),
	HX_HCSTRING("set_lineSpacing","\x92","\x1e","\xbc","\x8c"),
	HX_HCSTRING("set_letterSpacing","\xa0","\x9a","\xe1","\x1e"),
	HX_HCSTRING("set_autoUpperCase","\x26","\xbb","\x47","\xdd"),
	HX_HCSTRING("set_wordWrap","\x31","\xec","\xed","\xca"),
	HX_HCSTRING("set_wrapByWord","\x68","\x4d","\x95","\x0e"),
	HX_HCSTRING("set_autoSize","\x4d","\x67","\x8c","\xf9"),
	HX_HCSTRING("set_padding","\xf4","\xc0","\xe4","\x60"),
	HX_HCSTRING("set_numSpacesInTab","\xda","\x4d","\x22","\xa7"),
	HX_HCSTRING("set_background","\xab","\x04","\x33","\xbc"),
	HX_HCSTRING("set_backgroundColor","\xb8","\x10","\xef","\xd4"),
	HX_HCSTRING("set_borderStyle","\x48","\xa5","\x43","\xcd"),
	HX_HCSTRING("set_borderColor","\x7a","\x71","\x82","\x93"),
	HX_HCSTRING("set_borderSize","\x8a","\x70","\x03","\x9d"),
	HX_HCSTRING("set_borderQuality","\x96","\x78","\x03","\xa3"),
	HX_HCSTRING("get_numLines","\xe2","\xa5","\x2b","\xe7"),
	HX_HCSTRING("get_textWidth","\xf0","\x19","\xb4","\x24"),
	HX_HCSTRING("get_textHeight","\xbd","\x10","\x32","\xaf"),
	HX_HCSTRING("get_lineHeight","\x44","\x8b","\xe9","\x4c"),
	HX_HCSTRING("get_width","\x5d","\x12","\x0c","\x0e"),
	HX_HCSTRING("get_height","\xb0","\x77","\xd3","\xf2"),
	::String(null()) };

static void FlxBitmapText_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxBitmapText_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxBitmapText_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxBitmapText_obj::__mClass,"__mClass");
};

#endif

hx::Class FlxBitmapText_obj::__mClass;

void FlxBitmapText_obj::__register()
{
	hx::Object *dummy = new FlxBitmapText_obj;
	FlxBitmapText_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("flixel.text.FlxBitmapText","\x7f","\x8e","\x6b","\xd7");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = FlxBitmapText_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(FlxBitmapText_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< FlxBitmapText_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxBitmapText_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxBitmapText_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxBitmapText_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace flixel
} // end namespace text
